Картотека (Zettelkasten) по терминам Hypercode
Этот документ представляет собой набор взаимосвязанных карточек-определений для ключевых понятий проекта Hypercode. Каждая карточка — это атомарная заметка, которую можно использовать в Obsidian или другой системе, поддерживающей вики-ссылки.
Раздел 1: Ядро языка и синтаксис
Complexity Management
Управление сложностью — это одна из центральных задач, которую решает Hypercode. В контексте проекта это относится к предотвращению хаоса в конфигурационных файлах по мере роста системы. Вместо того чтобы сложность "размазывалась" по императивному коду, она выносится в декларативные файлы .hcs, а для борьбы с ней вводятся такие механизмы, как [[@import Directive]] и [[Mixins/Templates]], которые позволяют структурировать и переиспользовать конфигурацию, избегая [[YAML Hell]].
Declarative Cliff
«Декларативный обрыв» — это концептуальный предел, с которым сталкиваются декларативные языки, подобные HCS. Он возникает, когда требуемая логика конфигурации становится слишком сложной или динамической для выражения в рамках синтаксиса [[DSL]]. В таких случаях разработчики вынуждены либо чрезмерно усложнять конфигурацию, либо прибегать к обходным маневрам. Hypercode решает эту проблему с помощью контролируемых [[Declarative Escape Hatches]].
DSL (Domain-Specific Language)
DSL (Предметно-ориентированный язык) — это язык программирования, созданный для решения задач в одной конкретной области, в противовес языкам общего назначения (GPL), таким как Python или Java. В Hypercode язык .hcs является DSL, специально разработанным для декларативного описания конфигурации и сборки приложений. Его синтаксис ограничен, но очень выразителен именно в этой узкой задаче.
@import Directive
Директива @import — это языковая конструкция в .hcs, позволяющая включить содержимое одного файла конфигурации в другой. Это ключевой инструмент для [[Complexity Management]], так как он дает возможность разбивать монолитные конфигурации на небольшие, логически сгруппированные и переиспользуемые модули (например, database.hcs, logging.hcs).
YAML Hell
«YAML ад» — это разговорный термин, описывающий ситуацию, когда конфигурационные файлы в формате YAML (или подобном, как .hcs) становятся настолько большими, вложенными и сложными, что их становится невозможно читать, поддерживать и отлаживать. Hypercode борется с этим явлением с помощью механизмов модуляризации, таких как [[@import Directive]] и [[Mixins/Templates]].
BNF (Backus–Naur form)
Форма Бэкуса–Наура (BNF) — это формальная система для описания синтаксиса языков. В контексте Hypercode, BNF используется для создания точной и недвусмысленной грамматики для языков .hc и .hcs. Наличие формальной грамматики является обязательным условием для разработки парсеров, линтеров и других инструментов.
HCS parser
Парсер HCS — это компонент [[reference runtime]], отвечающий за чтение текстового .hcs файла и его преобразование во внутреннюю структуру данных (например, в дерево разбора), которую затем может использовать движок разрешения правил. Он реализует грамматику, описанную с помощью [[BNF]].
reference runtime
Эталонный рантайм — это основная, официальная реализация исполнительной среды Hypercode. Он служит стандартом, с которым должны сверяться все остальные (возможно, сторонние) реализации. Эталонный рантайм отвечает за парсинг .hc и .hcs файлов, применение [[import cascade]], разрешение правил и, в конечном итоге, за сборку и запуск приложения.
relative/absolute paths
Относительные/абсолютные пути — это два способа указания местоположения файлов при использовании директивы [[@import Directive]]. Абсолютные пути указывают полный путь от корня файловой системы, в то время как относительные — путь от местоположения текущего .hcs файла. Поддержка обоих типов путей важна для гибкости организации проекта.
environment variable expansion
Раскрытие переменных окружения — это способность рантайма подставлять значения из переменных окружения операционной системы в .hcs файлы. Это позволяет делать конфигурации более гибкими и безопасными, не "зашивая" в них чувствительные данные или специфичные для окружения параметры. Например, host: "${DB_HOST}".
import cascade
Каскад импортов — это механизм, определяющий порядок и приоритет применения правил из разных .hcs файлов, связанных через директиву [[@import Directive]]. Правила каскада определяют, как объединяются и переопределяются стили, если они заданы в нескольких файлах. В Hypercode правила из импортирующего (основного) файла имеют более высокий приоритет, чем из импортируемых.
conflict resolution rules
Правила разрешения конфликтов — это часть [[Resolution Semantics]], которая точно определяет, какое значение будет применено к свойству компонента, если на него нацелено несколько правил с одинаковой специфичностью. В Hypercode, как и в CSS, побеждает правило, которое было определено в исходном коде позже.
Declarative Escape Hatches
«Декларативные лазейки» — это специальные, строго контролируемые конструкции в HCS, которые позволяют "выйти" за пределы чисто декларативного синтаксиса для решения сложных задач. Они являются ответом на проблему [[Declarative Cliff]]. Основные "лазейки" в Hypercode — это [[@factory]] и [[@expression]].
@factory
Директива @factory — это одна из [[Declarative Escape Hatches]], позволяющая делегировать создание компонента не рантайму, а специальной функции или классу-фабрике, написанной на языке общего назначения (например, Python). Это необходимо, когда логика создания объекта слишком сложна для [[DSL]] и требует императивного кода.
@expression
Директива @expression — это одна из [[Declarative Escape Hatches]], которая позволяет вычислять значения свойств с помощью простых, безопасных выражений. Эти выражения выполняются в изолированной среде ([[safe, sandboxed expression evaluator]]) и имеют доступ только на чтение к контексту, что позволяет делать конфигурацию более динамичной без ущерба для безопасности.
runtime contract (interface)
Контракт рантайма (интерфейс) — это формальное описание того, как внешний код (например, фабрика для [[@factory]]) должен взаимодействовать с рантаймом Hypercode. Этот контракт определяет, какие методы и данные рантайм предоставляет фабрике (например, доступ к другим зависимостям), и что фабрика должна вернуть в результате.
safe, sandboxed expression evaluator
Безопасный, изолированный вычислитель выражений — это компонент рантайма, который исполняет код, написанный в директивах [[@expression]]. "Изолированный" (sandboxed) означает, что у этого кода нет доступа к файловой системе, сети или другим потенциально опасным ресурсам. Он может работать только с данными, которые ему явно предоставили.
read-only access
Доступ только на чтение — это принцип безопасности, применяемый к [[@expression]]. Он означает, что выражения могут только читать значения из контекста (например, переменные окружения), но не могут их изменять. Это предотвращает побочные эффекты и сохраняет декларативную природу конфигурации.
Security Policy Gating
Контроль через политику безопасности — это требование, согласно которому использование потенциально мощных функций, таких как [[Declarative Escape Hatches]], должно быть явно разрешено в конфигурации рантайма. По умолчанию они отключены, чтобы предотвратить случайное или злонамеренное исполнение небезопасного кода.
attribute selectors
Селекторы по атрибутам — это способ нацеливания на компоненты в .hcs на основе наличия или значения их свойств (атрибутов), которые могли быть заданы правилами с более низким приоритетом. Например, WebServer[secure=true] выберет только те веб-серверы, у которых свойство secure уже установлено в true.
combinators
Комбинаторы — это специальные символы в селекторах .hcs, которые описывают взаимосвязь между компонентами, позволяя создавать более точные правила. Примеры в Hypercode: + (соседний селектор) и > (дочерний селектор).
selector specificity calculation algorithm
Алгоритм расчета специфичности селекторов — это формальный набор правил, который определяет, какой из селекторов является "более важным" или "более точным". Рантайм использует этот алгоритм для решения, какое из конфликтующих правил применить. Например, селектор по ID (#my-id) обычно более специфичен, чем селектор по классу (.my-class).
formal specificity scoring table
Формальная таблица подсчета очков специфичности — это официальный документ или часть спецификации, который детально описывает, сколько "очков" дает каждый тип селектора (ID, класс, атрибут, тип) при использовании [[selector specificity calculation algorithm]]. Наличие такой таблицы устраняет неоднозначность и является обязательным для совместимости разных рантаймов.
Mixins/Templates
Миксины/Шаблоны — это механизм в HCS, позволяющий определять переиспользуемые блоки конфигурации и "подмешивать" их в разные правила. Это основной инструмент для следования принципу [[DRY (Don't Repeat Yourself)]] в .hcs файлах.
DRY (Don't Repeat Yourself)
Не повторяйся (DRY) — это фундаментальный принцип разработки программного обеспечения, направленный на снижение дублирования кода. В контексте Hypercode, применение этого принципа к .hcs файлам с помощью [[Mixins/Templates]] помогает избежать ошибок и упрощает поддержку конфигураций.
Sass/SCSS
Sass/SCSS — это препроцессор для CSS, который расширяет его синтаксис, добавляя такие возможности, как переменные, вложенность и миксины. В Hypercode он упоминается как источник вдохновения для реализации [[Mixins/Templates]], так как решает схожую проблему дублирования в декларативных языках стилей.
pre-processing step
Шаг пре-процессинга — это этап работы рантайма, который выполняется до основного процесса разрешения правил. На этом шаге рантайм обрабатывает такие конструкции, как [[Mixins/Templates]], фактически подставляя их содержимое в нужные места, прежде чем начнется [[main cascade resolution]].
main cascade resolution
Основное разрешение каскада — это ключевой процесс в рантайме Hypercode, во время которого он собирает все правила из всех .hcs файлов, сортирует их в соответствии со специфичностью и порядком, а затем последовательно применяет к компонентам из .hc файла, чтобы определить их финальные свойства.
Resolution Semantics
Семантика разрешения — это формальное, математически точное описание всего процесса [[main cascade resolution]]. Она включает в себя [[selector specificity calculation algorithm]], [[property merge strategy]] и [[conflict resolution rules]], а также предоставляет гарантии [[determinism]] и [[invariance guarantees]]. Это самая важная часть спецификации для обеспечения совместимости рантаймов.
property merge strategy
Стратегия слияния свойств — это набор правил, определяющих, как объединяются свойства компонента, если на него нацелено несколько неконфликтующих правил. Например, если одно правило задает port, а другое host, то в результате компонент получит оба этих свойства.
determinism
Детерминизм — это гарантия, предоставляемая [[Resolution Semantics]], которая утверждает, что при одинаковых входных данных (.hc и .hcs файлы) результат разрешения всегда будет абсолютно одинаковым, независимо от реализации рантайма или окружения.
invariance guarantees
Гарантии инвариантности — это набор утверждений в [[Resolution Semantics]], описывающих, какие свойства системы остаются неизменными в процессе разрешения. Например, инвариантом может быть то, что порядок компонентов в .hc файле не влияет на применение правил, если в селекторах не используются комбинаторы порядка.
mathematical model
Математическая модель — это способ формализации [[Resolution Semantics]] с использованием математического аппарата (например, теории множеств или графов). Создание такой модели является конечной целью для достижения полной однозначности спецификации.
formal specification
Формальная спецификация — это документ, который описывает язык и его поведение с максимальной точностью и без двусмысленностей, используя такие инструменты, как [[BNF]] и [[mathematical model]]. Она служит первоисточником для всех разработчиков рантаймов и инструментов.
"golden fixtures"
«Золотые» тестовые наборы — это эталонный набор, состоящий из .hc файлов, .hcs файлов и ожидаемых результатов их разрешения. Этот набор используется для автоматической проверки любой реализации рантайма на соответствие [[formal specification]]. Если рантайм проходит все тесты из этого набора, он считается совместимым.
Раздел 2: Инструментарий и опыт разработки (DX)
high cognitive load
Высокая когнитивная нагрузка — это ментальное усилие, которое требуется от разработчика для понимания и работы с системой. Одна из целей Hypercode — снизить эту нагрузку при чтении бизнес-логики, однако новая парадигма сама по себе может создавать нагрузку на этапе изучения. Качественные инструменты призваны минимизировать этот эффект.
steep learning curve
Крутая кривая обучения — это характеристика технологии, которая требует значительных усилий и времени для освоения. Hypercode, как новая парадигма, потенциально обладает этим свойством. Раздел дорожной карты по DX направлен на "сглаживание" этой кривой с помощью интуитивно понятных инструментов и качественной документации.
"killer app"
«Убойное приложение» — это разговорный термин для обозначения той самой функции или инструмента, которая делает технологию чрезвычайно привлекательной и обеспечивает ее успех. В контексте Hypercode таким "killer app" должен стать [[Configuration Inspector]], поскольку он решает главную проблему декларативных каскадных систем — сложность отладки.
resolved configuration graph
Разрешенный граф конфигурации — это итоговая структура данных, которую создает рантайм после применения всех .hcs правил к .hc файлу. Этот граф представляет собой полное описание всех компонентов приложения и их финальных, сконфигурированных свойств. Именно этот граф является входными данными для [[Configuration Inspector]].
explain mode
Режим объяснения — это специальный режим работы [[Configuration Inspector]], который не просто показывает финальные свойства компонента, но и детально объясняет, почему они стали именно такими: какие правила были применены, в каком порядке, какие были переопределены и какова специфичность каждого из них.
"Styles" panel
Панель «Стили» — это элемент пользовательского интерфейса в [[Configuration Inspector]], который имитирует аналогичную панель в инструментах разработчика веб-браузеров. Она в удобном виде отображает все правила, примененные к выбранному компоненту, и позволяет интерактивно исследовать каскад.
Language Server Protocol (LSP)
Протокол языкового сервера (LSP) — это стандарт, созданный Microsoft, который определяет протокол взаимодействия между редактором кода (IDE) и "языковым сервером". Сервер предоставляет такие функции, как автодополнение, диагностика и форматирование. Создание одного LSP-сервера для Hypercode позволяет легко интегрировать поддержку языка во множество редакторов (VS Code, JetBrains IDEs и др.).
syntax highlighting
Подсветка синтаксиса — базовая функция IDE, которая раскрашивает разные части кода (ключевые слова, строки, комментарии) в разные цвета, улучшая читаемость. Это одна из первых задач при реализации поддержки языка в редакторе.
semantic autocompletion
Семантическое автодополнение — это продвинутая функция IDE, которая предлагает варианты завершения кода, основываясь не только на синтаксисе, но и на смысле (семантике) всего проекта. Например, при написании селектора в .hcs, IDE предложит имена компонентов, реально существующих в .hc файле.
live validation
Валидация в реальном времени — это функция IDE, которая проверяет код на ошибки по мере его написания и немедленно подчеркивает проблемные места, не дожидаясь компиляции или запуска.
go-to-definition
Переход к определению — это функция IDE, которая позволяет по клику на имени переменной, функции или, в случае Hypercode, компонента в селекторе, мгновенно перейти к месту в коде, где этот элемент был определен.
"quick-fixes"
«Быстрые исправления» — это предлагаемые IDE автоматические действия для исправления обнаруженных ошибок или предупреждений линтера. Например, если линтер нашел дублирующийся блок кода, он может предложить "quick-fix" для его извлечения в [[Mixins/Templates]].
pluggable rule architecture
Плагиновая архитектура правил — это дизайн [[HCS Linter]], который позволяет пользователям или сторонним разработчикам легко добавлять свои собственные правила проверки, не изменяя основной код линтера. Это делает инструмент гибким и расширяемым.
overly-specific selectors
Чрезмерно специфичные селекторы — это анти-паттерн в .hcs, когда селектор становится слишком длинным и хрупким (например, app > panel > section > button). [[HCS Linter]] должен обнаруживать такие селекторы и предупреждать о них, так как они усложняют поддержку и переопределение стилей.
unreferenced secrets
Неиспользуемые секреты — это потенциальная проблема безопасности, когда в хранилище секретов есть значение, но ни одно правило в .hcs на него не ссылается. [[HCS Linter]] может интегрироваться с системами управления секретами для обнаружения таких "висящих" данных.
wildcard selectors
Селекторы с использованием * (wildcard) — это селекторы, которые нацелены на все компоненты (*). Их использование может быть опасным, так как они имеют низкую специфичность, но могут непреднамеренно изменить конфигурацию большого количества компонентов. [[HCS Linter]] должен предупреждать о таком использовании.
official language specification
Официальная спецификация языка — это документ ([[formal specification]]), который является единственным источником правды о том, как должен работать язык Hypercode. [[CLI Golden Test Runner]] проверяет рантаймы на соответствие именно этой спецификации.
golden fixture suite
Синоним для [[«golden fixtures»]].
"Hypercode Compliant" certification program
Программа сертификации "Hypercode Compliant" — это инициатива, направленная на создание экосистемы совместимых инструментов. Сторонние разработчики могут запустить свои реализации рантайма через [[CLI Golden Test Runner]], и если все тесты пройдены, они получают официальный "знак качества", подтверждающий их совместимость со спецификацией.
Раздел 3: Производительность и модель исполнения
real-world workloads
Реальные рабочие нагрузки — это сценарии для бенчмаркинга, которые имитируют использование Hypercode в настоящих, сложных проектах, а не в простых синтетических тестах. Они включают большое количество компонентов, импортов и сложных правил, что позволяет получить реалистичную оценку производительности.
JIT startup overhead
Накладные расходы на запуск в режиме JIT — это дополнительное время, которое требуется приложению на Hypercode для запуска по сравнению с аналогичным приложением, написанным на чистом императивном коде. Эти расходы связаны с необходимостью парсить и разрешать .hcs файлы при каждом старте. Одна из целей проекта — минимизировать этот показатель.
JIT code
JIT-код (Just-In-Time) — в контексте Hypercode это относится к стандартной модели исполнения, когда рантайм читает и интерпретирует .hcs файлы "на лету" при каждом запуске приложения. Это обеспечивает максимальную гибкость, но создает [[JIT startup overhead]]. Противоположность — [[AOT code]].
AOT (Ahead-Of-Time) Compilation
AOT-компиляция (Ahead-Of-Time) — это альтернативная модель исполнения, при которой .hc и .hcs файлы компилируются в оптимизированный императивный код на целевом языке заранее, до запуска приложения. Это полностью устраняет [[JIT startup overhead]] и является рекомендуемым подходом для производственных сред.
AOT compiler
AOT-компилятор (hc-compile) — это инструмент, который выполняет [[AOT (Ahead-Of-Time) Compilation]]. Он принимает на вход конфигурационные файлы и генерирует исполняемый код, который уже не содержит логики парсинга, а напрямую создает и связывает компоненты.
direct-instantiation code
Код с прямым инстанцированием — это результат работы [[AOT compiler]]. Это императивный код, который напрямую вызывает конструкторы классов и передает им зависимости, как если бы он был написан вручную, без использования DI-фреймворка или Hypercode рантайма.
runtime parsing
Парсинг в рантайме — это процесс чтения и анализа .hcs файлов, который происходит при каждом запуске приложения в режиме [[JIT code]]. [[AOT (Ahead-Of-Time) Compilation]] устраняет необходимость в этом шаге.
resolution overhead
Накладные расходы на разрешение — это время, которое рантайм тратит на [[main cascade resolution]]. Является основной составляющей [[JIT startup overhead]].
security capability checks
Проверки возможностей безопасности — это требование к [[AOT compiler]], согласно которому он должен встраивать в сгенерированный [[AOT code]] те же проверки безопасности (см. [[Capability Enforcement in Resolution Engine]]), которые выполняет рантайм в режиме JIT. Это гарантирует, что скомпилированный код так же безопасен, как и интерпретируемый.
AOT code
AOT-код — это исполняемый код, сгенерированный [[AOT compiler]]. Он не требует [[reference runtime]] для своего выполнения.
runtime configuration resolution overhead
Синоним для [[resolution overhead]].
Incremental Resolution (Hot Reload)
Инкрементальное разрешение (Горячая перезагрузка) — это оптимизация для режима разработки (watch mode), при которой рантайм не пересчитывает весь граф конфигурации при изменении одного файла, а определяет и обновляет только те части, которые были затронуты изменением. Это обеспечивает почти мгновенную обратную связь.
watch mode
Режим отслеживания (watch mode) — это режим работы рантайма, в котором он следит за изменениями в .hc и .hcs файлах и автоматически перезагружает конфигурацию при их сохранении, используя [[Incremental Resolution (Hot Reload)]].
watch flag
Флаг --watch — это флаг командной строки для запуска рантайма Hypercode в [[watch mode]].
Раздел 4: Безопасность и доверие
secure-by-design
Безопасность по определению (secure-by-design) — это подход к разработке, при котором вопросы безопасности являются неотъемлемой частью архитектуры с самого начала, а не добавляются в конце. Hypercode стремится следовать этому принципу, встраивая безопасность в ядро языка и рантайма.
secret:// URI scheme
Схема URI secret:// — это стандартизированный способ ссылки на секреты из .hcs файлов, который позволяет избежать их прямого хранения в коде. URI указывает, откуда нужно загрузить секрет (например, secret://vault/path/to/key). Обработкой этого URI занимается [[SecretProvider model]].
SecretProvider model
Модель провайдеров секретов — это плагиновая архитектура в рантайме, которая позволяет подключать разные "провайдеры" для работы с различными хранилищами секретов (HashiCorp Vault, AWS Secrets Manager и т.д.). Рантайм делегирует провайдеру задачу получения секрета по адресу, указанному в [[secret:// URI scheme]].
hypercode.lock
Файл hypercode.lock — это манифест, похожий на package-lock.json в npm, который содержит [[cryptographic hashes]] всех .hcs файлов, используемых в проекте. Этот файл является основой для механизма [[HCS Signing & Verification]], гарантируя целостность конфигурации.
cryptographic hashes
Криптографические хеши — это уникальные "отпечатки" файлов, вычисленные с помощью криптографического алгоритма. Любое, даже малейшее, изменение в файле приводит к кардинальному изменению его хеша. Хранение хешей в hypercode.lock позволяет убедиться, что файлы конфигурации не были изменены.
"secure mode"
«Безопасный режим» — это специальный режим работы рантайма, в котором он требует обязательной проверки цифровой подписи файла hypercode.lock перед выполнением. В этом режиме любая неподписанная или измененная конфигурация будет отклонена.
HCS Signing & Verification
Подпись и верификация HCS — это механизм безопасности, который позволяет гарантировать целостность (файлы не были изменены) и аутентичность (файлы были созданы доверенным источником) конфигурации. Он основан на [[cryptographic hashes]] в файле [[hypercode.lock]] и цифровой подписи этого файла.
Agent Passport security model
Модель безопасности "Паспорт Агента" — это концепция, согласно которой каждый компонент (агент) в системе имеет декларативный манифест ("паспорт"), описывающий его возможности: к каким файлам он может обращаться, с какими сетевыми адресами может соединяться и т.д. Hypercode интегрирует эту модель в ядро через [[Capability Enforcement in Resolution Engine]].
architectural declaration
Архитектурная декларация — в контексте Hypercode это .hc файл. Он описывает структуру приложения. Связка этой декларации с [[security policy]] означает, что безопасность становится неотъемлемой частью архитектуры.
security policy
Политика безопасности — это набор правил, определяющих, что разрешено и что запрещено делать компонентам системы. В Hypercode политика безопасности определяется с помощью [[Agent Passport security model]] и принудительно применяется рантаймом.
capability bounds
Границы возможностей — это конкретные разрешения, определенные в "паспорте" компонента в рамках [[Agent Passport security model]]. Например, file_access: read_only("/data").
"passport"
«Паспорт» — это декларативный манифест компонента, который является центральным элементом [[Agent Passport security model]].
Раздел 6: Интеграция и совместимость
"Adapter for Legacy Code" Pattern
Паттерн «Адаптер для унаследованного кода» — это официальный, документированный способ интеграции Hypercode в существующие проекты, код которых не следует современным принципам DI. Паттерн заключается в создании специального класса-"обертки" ([[«wrapper» pattern]]), который скрывает "нечистоту" старого кода и предоставляет для Hypercode чистый, конфигурируемый интерфейс.
"wrapper" pattern
Синоним для [[«Adapter for Legacy Code» Pattern]].
security sandbox wrappers
Обертки-песочницы безопасности — это требование к реализации [[«Adapter for Legacy Code» Pattern]], согласно которому класс-адаптер должен не только преобразовывать интерфейс, но и по возможности ограничивать (изолировать) унаследованный код, чтобы он не мог получить несанкционированный доступ к ресурсам.
External Compatibility Layer (Generators)
Внешний слой совместимости (Генераторы) — это функциональность Hypercode, позволяющая ему служить единым источником правды для конфигурации не только самого приложения, но и внешних систем, таких как Terraform или Kubernetes. Это реализуется через [[«generator» architecture]].
"generator" architecture
Архитектура генераторов — это плагиновая система в Hypercode, которая позволяет подключать "генераторы", способные преобразовывать разрешенную конфигурацию Hypercode в формат, понятный другим системам (например, в .tfvars для Terraform).
Terraform: .tfvars
.tfvars — это файлы переменных для [[Terraform]], инструмента для управления инфраструктурой как кодом. Генератор для Terraform в Hypercode позволяет управлять переменными инфраструктуры из тех же .hcs файлов, что и приложение.
Terraform
Terraform — это популярный инструмент для управления инфраструктурой как кодом (IaC).
Kubernetes: ConfigMap, Secret
ConfigMap и Secret — это стандартные ресурсы в [[Kubernetes]] для хранения конфигурационных данных и секретов соответственно. Генератор для Kubernetes в Hypercode позволяет автоматически создавать эти ресурсы на основе .hcs правил.
Kubernetes
Kubernetes — это открытая платформа для автоматизации развертывания, масштабирования и управления контейнеризированными приложениями.
Stable ABI/IPC Contract
Стабильный контракт ABI/IPC — это формализованный и версионируемый протокол, который определяет, как инструменты экосистемы Hypercode (IDE, CLI) взаимодействуют с рантаймом. Стабильность этого контракта критически важна для [[language-agnostic]] подхода.
language-agnostic
Языко-независимый — это свойство системы или стандарта, которое позволяет ему работать с компонентами, написанными на разных языках программирования. Hypercode стремится быть языко-независимым слоем оркестрации.
Application Binary Interface
ABI (Двоичный интерфейс приложений) — это низкоуровневый контракт между программными компонентами, определяющий, как они взаимодействуют на уровне машинного кода. В контексте Hypercode этот термин используется как часть [[Stable ABI/IPC Contract]] для обозначения строгого, машиночитаемого интерфейса.
Inter-Process Communication
IPC (Межпроцессное взаимодействие) — это набор механизмов, позволяющих разным процессам (например, IDE и рантайму Hypercode) обмениваться данными. [[Stable ABI/IPC Contract]] стандартизирует это взаимодействие.
JSON-RPC
JSON-RPC — это простой протокол для удаленного вызова процедур, использующий JSON для кодирования сообщений. Является одним из кандидатов для реализации [[Stable ABI/IPC Contract]] из-за своей простоты.
gRPC
gRPC — это высокопроизводительный фреймворк для удаленного вызова процедур, разработанный Google. Он использует Protocol Buffers для сериализации данных и является кандидатом для [[Stable ABI/IPC Contract]] для сценариев, требующих высокой производительности.
WIT (WebAssembly Interface Types)
WIT (Типы интерфейсов WebAssembly) — это стандарт для описания интерфейсов между компонентами WebAssembly и хост-системой. Является перспективным кандидатом для [[Stable ABI/IPC Contract]] благодаря своей ориентации на безопасность и языковую независимость.
.wit
.wit — это расширение файла, используемое для определения интерфейсов в формате [[WIT (WebAssembly Interface Types)]].
.proto
.proto — это расширение файла, используемое для определения сервисов и сообщений для [[gRPC]] с помощью Protocol Buffers.
Reference Runtime
Синоним для [[reference runtime]].
Semantic Versioning (SemVer)
Семантическое версионирование (SemVer) — это формальный стандарт для присвоения номеров версиям программного обеспечения. Он предписывает, как изменять номер версии (МАЖОР.МИНОР.ПАТЧ) в зависимости от того, являются ли изменения ломающими. [[Stable ABI/IPC Contract]] должен строго следовать этому стандарту.
Раздел 7: Инфраструктура и обеспечение качества (QA)
CI/CD pipeline
CI/CD пайплайн — это автоматизированный процесс в современной разработке, который включает непрерывную интеграцию (CI) — сборку и тестирование кода при каждом изменении, и непрерывную доставку/развертывание (CD) — автоматическую подготовку к релизу.
CI Service
CI-сервис — это платформа (например, [[GitHub Actions]]), которая предоставляет инфраструктуру и инструменты для запуска [[CI/CD pipeline]].
GitHub Actions
GitHub Actions — это популярный [[CI Service]], встроенный в платформу GitHub.
Unit Tests
Модульные тесты (Unit Tests) — это тесты, которые проверяют корректность работы самых маленьких, изолированных частей кода (модулей, функций).
Integration Tests
Интеграционные тесты — это тесты, которые проверяют корректность взаимодействия нескольких компонентов системы друг с другом. В Hypercode это, в первую очередь, запуск [[«golden fixtures»]].
Static Analysis
Статический анализ — это анализ кода без его фактического выполнения. В Hypercode это включает работу [[HCS Linter]] и других инструментов, которые ищут потенциальные ошибки, уязвимости и нарушения стиля.
Security Scanning
Сканирование безопасности — это часть [[CI/CD pipeline]], на которой автоматические инструменты проверяют код и его зависимости на наличие известных уязвимостей.
Merge Gate
Шлюз для слияния — это правило в системе контроля версий, которое запрещает слияние ветки (например, Pull Request), если [[CI/CD pipeline]] для нее не был успешно завершен. Это является обязательным требованием для поддержания качества основной ветки.
mandatory requirement
Обязательное требование — в контексте дорожной карты это означает, что задача или условие не подлежит обсуждению и должно быть выполнено для успешного завершения этапа.
Version Compatibility Testing
Тестирование на версионную совместимость — это процесс, который гарантирует, что новая версия рантайма обратно совместима с конфигурациями, написанными для предыдущих версий, в соответствии с правилами [[Semantic Versioning (SemVer)]].
polyglot ecosystem
Полиглотная экосистема — это сообщество и набор инструментов вокруг технологии, которые поддерживают и поощряют разработку на разных языках программирования. Создание такой экосистемы — одна из стратегических целей Hypercode.
quality standard
Стандарт качества — это набор формальных требований и тестов (например, [[«golden fixtures»]]), которым должна соответствовать любая реализация, чтобы считаться качественной и совместимой.
"badge of honor"
«Знак почета» — это метафора для официального значка [[«Hypercode Compliant» SVG badge]], который служит публичным признанием того, что сторонняя реализация соответствует [[quality standard]].
Certification Process
Процесс сертификации — это документированный и автоматизированный набор шагов, который должны пройти разработчики сторонних рантаймов, чтобы получить [[«Hypercode Compliant» SVG badge]].
"Hypercode Compliant" SVG badge
SVG-значок "Hypercode Compliant" — это официальный графический значок, который разработчики сертифицированных рантаймов могут размещать в своих репозиториях для демонстрации их совместимости со спецификацией.
List of Certified Runtimes
Список сертифицированных рантаймов — это официальный, публичный список на сайте проекта, который служит каталогом всех сторонних реализаций, прошедших [[Certification Process]].