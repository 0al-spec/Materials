# Создание агентского приложения на Hypercode

Вот как можно описать агентское приложение на Hypercode .hc и добавить ему Guardrails с помощью .hcs, используя принципы, изложенные в предоставленных документах.

[cite_start]Идея состоит в том, чтобы рассматривать Guardrails не как неотъемлемую часть логики агента, а как контекстную конфигурацию, которая применяется к ядру агента в зависимости от окружения (например, production, development или при работе с конфиденциальными данными).

## 1. Файл логической структуры (agent.hc)

Сначала мы описываем абстрактную структуру агента в .hc файле. [cite_start]Здесь нет никакой конкретики о том, как реализованы Guardrails, только логические блоки, к которым их можно "применить".

``` 
# agent.hc - Логическая структура агента

AgentApplication#customer-support-agent
  // Входной шлюз, где можно применить начальные проверки
  InputGateway.pre-execution-checks

  // Основная логика, обрабатывающая запрос пользователя
  CoreLogic
    // Шаг, где агент взаимодействует с LLM
    ModelInteraction.generates-response

    // Шаг, где агент решает использовать внешние инструменты
    ToolDecision

  // Выходной шлюз для финальных проверок перед ответом
  OutputGateway.post-execution-checks
``` 

 * [cite_start]AgentApplication#customer-support-agent: Главный компонент нашего агента с уникальным ID.
 * [cite_start].pre-execution-checks и .post-execution-checks: Мы используем классы для обозначения этапов, где могут применяться проверки Guardrails. Это позволяет нам гибко настраивать их.
 * .generates-response: Класс, специально выделенный для этапа генерации ответа, где необходимы проверки контента.

## 1. Файл конфигурации и Guardrails (config.hcs)

[cite_start]Теперь, используя мощь Hypercode Cascade Sheets (.hcs), мы "навешиваем" конкретные реализации Guardrails на нашу абстрактную структуру. Это позволяет менять уровень защиты, не трогая основной код агента.

```
# config.hcs - Конфигурация агента, включая Guardrails

# --- Базовые настройки (для разработки) ---
InputGateway:
  guardrails:
    - "log_all_inputs" // Просто логируем все для отладки

OutputGateway:
  guardrails:
    - "log_all_outputs"

ModelInteraction.generates-response:
  max_tokens: 500
  temperature: 0.7

# --- Правила для Production окружения ---
# Активируются при запуске с флагом env=production
@env[production]:
  // Применяем строгие Guardrails на вход
  .pre-execution-checks:
    guardrails:
      - "block_pii"           # Блокировать персональные данные
      - "detect_toxic_language" # Определять токсичность

  // Применяем Guardrails на сгенерированный LLM ответ
  .generates-response:
    guardrails:
      - "ensure_on_topic"     # Проверка, что ответ по теме
      - "check_factual_consistency" # Проверка фактов (если возможно)
      - "prevent_hallucinations"    # Механизм против галлюцинаций

  // Применяем Guardrails на финальный ответ пользователю
  .post-execution-checks:
    guardrails:
      - "verify_compliance_gdpr" # Убедиться в соответствии GDPR
      - "block_sensitive_data"   # Запретить утечку чувствительных данных
```

Как это работает?

 * [cite_start]Разделение логики и конфигурации: Файл agent.hc определяет что делает агент (его логическую структуру), а config.hcs определяет как он это делает (с какими параметрами и защитой).
 * [cite_start]Контекстная активация: С помощью правила @env[production] мы активируем строгий набор Guardrails только в продуктивной среде. При обычном запуске будут действовать только базовые правила (логирование), что удобно для разработки.
 * Гибкость и модульность: Вы можете создавать разные наборы правил. Например, @env[finance_dept] мог бы добавлять Guardrails, специфичные для финансового отдела, а @env[testing] — отключать их вовсе для прогона тестов.
 * [cite_start]Селекторы: Используя селекторы по классу (например, .pre-execution-checks), мы можем применить одно и то же правило к разным частям логики агента, если это потребуется в будущем.

[cite_start]Такой подход полностью соответствует философии Hypercode, делая сложную конфигурацию безопасности декларативной, управляемой и зависимой от контекста, не загрязняя при этом основную бизнес-логику приложения.
