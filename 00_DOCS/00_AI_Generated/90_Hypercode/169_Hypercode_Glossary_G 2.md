# Zettelkasten for Hypercode Terms

### .proto
Definition: .proto is the file extension used for defining services and messages for [[gRPC]] using Protocol Buffers.
Related: [[gRPC]]

### .wit
Definition: .wit is the file extension used for defining interfaces in the [[WIT (WebAssembly Interface Types)]] format.
Related: [[WIT (WebAssembly Interface Types)]]

### @expression
Definition: is one of the [[Declarative Escape Hatches]] that allows computing property values using simple, safe expressions. These expressions are executed in a sandboxed environment ([[safe, sandboxed expression evaluator]]) and have read-only access to the context, making the configuration more dynamic without compromising security.
Related: [[Declarative Escape Hatches]], [[Safe, Sandboxed Expression Evaluator]]

### @factory
Definition: is one of the [[Declarative Escape Hatches]] that allows delegating the creation of a component not to the runtime, but to a special function or factory class written in a general-purpose language (e.g., Python). This is necessary when the object creation logic is too complex for a [[DSL]] and requires imperative code.
Related: [[Declarative Escape Hatches]]

### @import Directive
Definition: is a language construct in .hcs that allows the contents of one configuration file to be included in another. It is a key tool for [[Complexity Management]], as it enables the breakdown of monolithic configurations into small, logically grouped, and reusable modules (e.g., database.hcs, logging.hcs).
Related: [[Complexity Management]]

### @rules
Definition: @rules are the core mechanism for [[Context-Aware Programming]] in Hypercode. It is a special syntax in a [[Hypercode Cascade Sheet (HCS)]] file that allows entire sections of configuration to be applied conditionally, based on the [[Execution Context]]. For example, @env[production]: activates the enclosed rules only when the execution environment is set to production.
Related: [[Context-Aware Programming]], [[Execution Context]], [[Hypercode Cascade Sheet (HCS)]]

### Adapter For Legacy Code Pattern
Definition: is an official, documented way to integrate Hypercode into existing projects whose code does not follow modern DI principles. The pattern consists of creating a special "wrapper" class ([[Â«wrapperÂ» pattern]]) that hides the "impurity" of the old code and provides a clean, configurable interface for Hypercode.

### Agent Passport Security Model
Definition: is a concept where each component (agent) in the system has a declarative manifest ("passport") describing its capabilities: which files it can access, which network addresses it can connect to, etc. Hypercode integrates this model into its core via [[Capability Enforcement in Resolution Engine]].
Related: [[Capability Enforcement In Resolution Engine]]

### AOT (ahead-Of-Time) Compilation
Definition: is an alternative execution model where .hc and .hcs files are compiled into optimized imperative code in the target language in advance, before the application is run. This completely eliminates [[JIT startup overhead]] and is the recommended approach for production environments.
Related: [[JIT Startup Overhead]]

### AOT Code
Definition: is the executable code generated by the [[AOT compiler]]. It does not require the [[reference runtime]] to execute.
Related: [[AOT Compiler]], [[Reference Runtime]]

### AOT Compiler
Definition: (hc-compile) is the tool that performs [[AOT (Ahead-Of-Time) Compilation]]. It takes configuration files as input and generates executable code that no longer contains parsing logic but instead directly creates and wires components.
Related: [[AOT (ahead-Of-Time) Compilation]]

### Application Binary Interface
Definition: An ABI (Application Binary Interface) is a low-level contract between software components that defines how they interact at the machine code level. In the context of Hypercode, this term is used as part of the [[Stable ABI/IPC Contract]] to denote a strict, machine-readable interface.
Related: [[Stable ABI/IPC Contract]]

### Architectural Declaration
Definition: â in the context of Hypercode, this is the .hc file. It describes the structure of the application. Linking this declaration with a [[security policy]] means that security becomes an integral part of the architecture.
Related: [[Security Policy]]

### AST (Abstract Syntax Tree)
Definition: An AST (Abstract Syntax Tree) or IR (Intermediate Representation) is the internal data structure that the [[HCS parser]] creates from the raw text of `.hc` and `.hcs` files. This tree represents the code's structure and semantics in a way that is easy for the machine to work with. The [[Resolution Algorithm]] and tools like the [[Configuration Inspector]] operate on this AST, not the raw text files. A formally specified AST is a prerequisite for building a stable ecosystem of tools.
Related: [[HCS Parser]], [[Resolution Algorithm]]

### Attribute Selectors
Definition: are a way of targeting components in .hcs based on the presence or value of their properties (attributes), which may have been set by lower-precedence rules. For example, WebServer[secure=true] will only select web servers where the secure property is already set to true.

### Badge Of Honor
Definition: A "badge of honor" is a metaphor for the official [[Â«Hypercode CompliantÂ» SVG badge]], which serves as public recognition that a third-party implementation meets the [[quality standard]].
Related: [[Hypercode Compliant SVG Badge]], [[Quality Standard]]

### BNF (BackusâNaur form)
Definition: is a formal system for describing the syntax of languages. In the context of Hypercode, BNF is used to create a precise and unambiguous grammar for the .hc and .hcs languages. A formal grammar is a prerequisite for developing parsers, linters, and other tools.

### Canonicalization
Definition: Canonicalization is the process of converting a configuration file into a standard, unambiguous textual representation before it is used in a security-sensitive operation. For [[HCS Signing & Verification]], `.hcs` files must be canonicalized (e.g., keys sorted alphabetically, consistent whitespace) before their [[Cryptographic Hashes]] are calculated. Without this step, two semantically identical files could have different hashes, making verification impossible. A [[Formatter]] is often used to perform canonicalization.
Related: [[Cryptographic Hashes]], [[Formatter]], [[HCS Signing & Verification]]

### Capability Bounds
Definition: are the specific permissions defined in a component's "passport" within the [[Agent Passport security model]]. For example, `file_access: read_only(â/dataâ)`.
Related: [[Agent Passport Security Model]]

### Capability Enforcement In Resolution Engine
Definition: Capability Enforcement is the process by which the [[Resolution Algorithm]] actively blocks configurations that violate a component's defined [[Security Policy]]. As part of the [[Agent Passport Security Model]], each component has declared [[Capability Bounds]] (e.g., which file paths or network ports it can access). If a rule attempts to configure a component with a value outside these bounds, the resolution engine will fail with a security error. This integrates security directly into the application assembly phase.
Related: [[Agent Passport Security Model]], [[Capability Bounds]], [[Resolution Algorithm]], [[Security Policy]]

### Cascade And Specificity
Definition: Cascade and Specificity is the set of principles that govern the [[Resolution Algorithm]]. It defines a strict order of precedence for applying rules, analogous to CSS:
1. Origin and Importance: Rules from more specific sources (e.g., a user override file) can take precedence.
2. Specificity: A selector's importance is calculated based on its components. A more specific selector (e.g., [[ID Selector]]) always overrides a less specific one (e.g., [[Type Selector]]).
3. Source Order: If two selectors have the same specificity, the one that appears later in the document wins.
Related: [[ID Selector]], [[Resolution Algorithm]], [[Type Selector]]

### Certification Process
Definition: The Certification Process is a documented and automated set of steps that developers of third-party runtimes must follow to obtain the [[Â«Hypercode CompliantÂ» SVG badge]].
Related: [[Hypercode Compliant SVG Badge]]

### Child Selector
Definition: A Child Selector targets commands that are direct children of another command in the .hc hierarchy. It is represented by the > combinator. For example, WebServer > Listen: targets a Listen command only if it is a direct child of a WebServer command.

### CI Service
Definition: A CI Service is a platform (e.g., [[GitHub Actions]]) that provides the infrastructure and tools to run a [[CI/CD pipeline]].
Related: [[CI/CD Pipeline]], [[Github Actions]]

### CI/CD Pipeline
Definition: A CI/CD pipeline is an automated process in modern software development that includes Continuous Integration (CI) â building and testing code with every change, and Continuous Delivery/Deployment (CD) â automatically preparing for a release.

### Class Selector
Definition: A Class Selector targets all commands in a .hc file that have been marked with a specific class, prefixed with a dot (.). For example, the selector .pooled: will apply its rules to any command marked with .pooled, such as Database.pooled. It is more specific than a [[Type Selector]].
Related: [[Type Selector]]

### Combinators
Definition: are special characters in .hcs selectors that describe the relationship between components, allowing for more precise rules. Examples in Hypercode include + (adjacent sibling selector) and > (child selector).

### Complexity Management
Definition: is one of the central problems that Hypercode solves. In the context of the project, this refers to preventing chaos in configuration files as a system grows. Instead of complexity being "smeared" across imperative code, it is externalized into declarative .hcs files. To combat this complexity, mechanisms like [[@import Directive]] and [[Mixins/Templates]] are introduced, which allow for structuring and reusing configuration, thus avoiding [[YAML Hell]].
Related: [[@import Directive]], [[Mixins/templates]], [[YAML Hell]]

### Conflict Diagnostics
Definition: Conflict Diagnostics are detailed messages generated by the [[Reference Runtime]] or [[Configuration Inspector]] that explain exactly why one rule was overridden by another. These diagnostics are essential for debugging and transparency, forming the data backbone for the inspector's [[Explain Mode]]. A typical diagnostic message would show the winning and losing rules, their respective [[Selector|Selectors]], their calculated [[Specificity]] scores, and their [[Rule Origin]] and [[Document Order]].
Related: [[Document Order]], [[Explain Mode]], [[Reference Runtime]], [[Rule Origin]], [[Selector]], [[Specificity]]

### Conflict Resolution Rules
Definition: are a part of the [[Resolution Semantics]] that precisely define which value will be applied to a component's property if it is targeted by multiple rules of the same specificity. In Hypercode, as in CSS, the rule that appears later in the source code wins.
Related: [[Resolution Semantics]]

### Context-Aware Programming
Definition: Context-Aware Programming is the ability of a program to dynamically alter its behavior and configuration based on its execution environment without changes to the core application logic. In Hypercode, this is achieved through [[@rules]] in [[Hypercode Cascade Sheet (HCS)]] files, which activate different configurations based on the [[Execution Context]] (e.g., production, development, testing).
Related: [[@rules]], [[Execution Context]], [[Hypercode Cascade Sheet (HCS)]]

### Cryptographic Hashes
Definition: are unique "fingerprints" of files, calculated using a cryptographic algorithm. Any change to a file, no matter how small, results in a drastically different hash. Storing hashes in hypercode.lock allows verification that the configuration files have not been altered.

### Declarative Cliff
Definition: is a conceptual limit faced by declarative languages like HCS. It occurs when the required configuration logic becomes too complex or dynamic to be expressed within the syntax of the [[DSL]]. In such cases, developers are forced to either create overly complicated configurations or resort to workarounds. Hypercode addresses this problem with controlled [[Declarative Escape Hatches]].
Related: [[Declarative Escape Hatches]]

### Declarative Escape Hatches
Definition: are special, strictly controlled constructs in HCS that allow "escaping" the purely declarative syntax to solve complex problems. They are the answer to the [[Declarative Cliff]] problem. The main "hatches" in Hypercode are [[@factory]] and [[@expression]].
Related: [[@expression]], [[@factory]], [[Declarative Cliff]]

### Declarative, Externalized DI
Definition: Declarative, Externalized Dependency Injection (DI) is a way of describing Hypercode's relationship to traditional DI. Unlike frameworks where DI is configured inside the application code (via annotations or code-based modules), Hypercode externalizes this configuration into .hcs files and uses a declarative syntax with selectors and rules, making it more dynamic and context-aware.

### Descendant Selector
Definition: A Descendant Selector is a type of [[Selector]] that targets commands that are descendants of another command in the [[Hypercode (.hc)]] hierarchy, regardless of how deeply nested they are. It is represented by a space between two selectors. For example, `WebServer .secure-port:` targets any element with the `.secure-port` class that exists anywhere inside a `WebServer` command.
Related: [[Child Selector]], [[Hypercode (.hc)]], [[Selector]]

### Determinism
Definition: is a guarantee provided by the [[Resolution Semantics]] which states that for the same input data (.hc and .hcs files), the result of the resolution will always be absolutely identical, regardless of the runtime implementation or environment.
Related: [[Resolution Semantics]]

### Direct-Instantiation Code
Definition: is the output of the [[AOT compiler]]. It is imperative code that directly calls class constructors and passes them dependencies, as if it were written by hand without a DI framework or the Hypercode runtime.
Related: [[AOT Compiler]]

### Document Order
Definition: Document Order is the principle used as the final tie-breaker in the [[Resolution Algorithm]] when two [[Selector|Selectors]] have the exact same [[Specificity]]. According to this rule, the selector that appears later in the document (or in an imported file) wins. This ensures that the resolution process is always deterministic. It is a key part of [[Conflict Resolution Rules]] and is synonymous with the concept of [[Source Order]].
Related: [[Conflict Resolution Rules]], [[Resolution Algorithm]], [[Selector]], [[Specificity]]

### DRY (Don't Repeat Yourself)
Definition: is a fundamental principle of software development aimed at reducing code duplication. In the context of Hypercode, applying this principle to .hcs files using [[Mixins/Templates]] helps to avoid errors and simplifies configuration maintenance.
Related: [[Mixins/templates]]

### DSL (Domain-Specific Language)
Definition: is a programming language created to solve problems in one specific domain, as opposed to general-purpose languages (GPLs) like Python or Java. In Hypercode, the .hcs language is a DSL specifically designed for the declarative description of application configuration and assembly. Its syntax is limited but highly expressive for this narrow task.

### Emitters
Definition: Emitters, also known as Generators, are pluggable modules that extend the Hypercode runtime to transform the final [[Resolved Configuration Graph]] into configuration files for external systems. This is the core of the [[External Compatibility Layer (Generators)]] and `"generator" architecture` . For example, a [[Terraform]] emitter could generate `.tfvars` files , and a [[Kubernetes]] emitter could generate `ConfigMap` and `Secret` manifests .
Related: [[External Compatibility Layer (Generators)]], [[Kubernetes]], [[Resolved Configuration Graph]], [[Terraform]]

### Environment Variable Expansion
Definition: is the runtime's ability to substitute values from the operating system's environment variables into .hcs files. This allows for more flexible and secure configurations by not hardcoding sensitive data or environment-specific parameters. For example, host: "${DB_HOST}".

### Environment-Agnostic
Definition: Environment-Agnostic is a property of the Hypercode paradigm, meaning it is not tied to any specific programming language, runtime, or deployment system. A [[reference runtime]] can be implemented in any language (Python, Rust, Java, etc.), making Hypercode a potential polyglot orchestration layer.
Related: [[Reference Runtime]]

### Executable Program Graph
Definition: An Executable Program Graph is the final, in-memory representation of the application after the [[Resolution Algorithm]] has been executed. It is not just a static configuration map, but a live graph of instantiated objects, configured and wired together, ready for execution. This distinguishes Hypercode from simple templating engines.
Related: [[Resolution Algorithm]]

### Execution Context
Definition: The Execution Context is the set of external states that determines which [[@rules]] in an HCS file are active at runtime. The most common context is the environment (env=production), but it could also include feature flags, user roles, or other dynamic conditions. The runtime uses the context to resolve the final configuration graph.
Related: [[@rules]]

### Explain Mode
Definition: is a special mode of the [[Configuration Inspector]] that not only shows the final properties of a component but also explains in detail why they are what they are: which rules were applied, in what order, which were overridden, and the specificity of each.

### External Compatibility Layer (Generators)
Definition: The External Compatibility Layer (Generators) is a feature of Hypercode that allows it to serve as a single source of truth for configuring not only the application itself but also external systems like Terraform or Kubernetes. This is implemented through a [[Â«generatorÂ» architecture]].
Related: [[Generator Architecture]]

### Formal Specification
Definition: is a document that describes a language and its behavior with maximum precision and without ambiguity, using tools like [[BNF]] and a [[mathematical model]]. It serves as the primary source of truth for all developers of runtimes and tools.
Related: [[Mathematical Model]]

### Formal Specificity Scoring Table
Definition: is an official document or part of the specification that details how many "points" each type of selector (ID, class, attribute, type) contributes when using the [[selector specificity calculation algorithm]]. The existence of such a table eliminates ambiguity and is mandatory for the compatibility of different runtimes.
Related: [[Selector Specificity Calculation Algorithm]]

### Formatter
Definition: A Formatter (`hc-fmt` or `hcs-fmt`) is a developer tool that automatically rewrites `.hc` and `.hcs` files into a standard, canonical style. It enforces consistent indentation, key ordering, and spacing. A formatter eliminates style debates and makes configurations more readable. Its most critical role is ensuring that files are in a predictable format before security operations, which is a prerequisite for reliable [[Canonicalization]].
Related: [[Canonicalization]]

### General Sibling Selector
Definition: The General Sibling Selector (`~`) is a [[Combinators|Combinator]] that targets commands that are siblings of and appear after a specified command, sharing the same parent in the [[Hypercode (.hc)]] hierarchy. For example, `PrimaryDB ~ ReplicaDB:` would apply a configuration to all `ReplicaDB` commands that follow the `PrimaryDB` command at the same indentation level. It is useful for configuring groups of related peer components.
Related: [[Combinators]], [[Hypercode (.hc)]]

### Generator Architecture
Definition: The "generator" architecture is a pluggable system in Hypercode that allows connecting "generators" capable of transforming the resolved Hypercode configuration into a format understood by other systems (e.g., into .tfvars for Terraform).

### Github Actions
Definition: GitHub Actions is a popular [[CI Service]] built into the GitHub platform.
Related: [[CI Service]]

### Go-To-Definition
Definition: is an IDE feature that allows a user to instantly jump to the place in the code where an element was defined by clicking on the name of a variable, function, or, in Hypercode's case, a component in a selector.

### Golden Fixtures
Definition: are a reference set consisting of .hc files, .hcs files, and the expected results of their resolution. This set is used to automatically verify any runtime implementation for compliance with the [[formal specification]]. If a runtime passes all tests from this set, it is considered compliant.
Section 2: Tooling & Developer Experience (DX)
Related: [[Formal Specification]]

### gRPC
Definition: gRPC is a high-performance remote procedure call framework developed by Google. It uses Protocol Buffers for data serialization and is a candidate for the [[Stable ABI/IPC Contract]] for scenarios requiring high performance.
Related: [[Stable ABI/IPC Contract]]

### HCS Linter
Definition: The HCS Linter is a static analysis tool that checks [[Hypercode Cascade Sheet (HCS)]] files for errors, potential bugs, stylistic issues, and anti-patterns. It is built on a [[Pluggable Rule Architecture]] , allowing for custom rule sets. Core responsibilities include identifying [[Overly-specific selectors]] , [[Wildcard Selectors]] , [[Unreferenced Secrets]] , and enforcing project-specific conventions.
Related: [[Hypercode Cascade Sheet (HCS)]], [[Overly-Specific Selectors]], [[Pluggable Rule Architecture]], [[Unreferenced Secrets]], [[Wildcard Selectors]]

### HCS Parser
Definition: is a component of the [[reference runtime]] responsible for reading a textual .hcs file and converting it into an internal data structure (like a parse tree), which can then be used by the rule resolution engine. It implements the grammar described using [[BNF]].
Related: [[Reference Runtime]]

### HCS Signing & Verification
Definition: is a security mechanism that guarantees the integrity (files have not been modified) and authenticity (files were created by a trusted source) of the configuration. It is based on [[cryptographic hashes]] in the [[hypercode.lock]] file and a digital signature of that file.
Related: [[Cryptographic Hashes]], [[Hypercode.lock]]

### High Cognitive Load
Definition: is the mental effort required from a developer to understand and work with a system. One of Hypercode's goals is to reduce this load when reading business logic, but the new paradigm itself can create a load during the learning phase. Quality tools are designed to minimize this effect.

### Hypercode (.hc)
Definition: Hypercode (.hc file) is a declarative file that describes the logical structure of a program in a minimal, indentation-based hierarchical format. It contains abstract commands or entities, augmented with optional class (.) and ID (#) markers for targeting. It is analogous to an HTML document's structure, defining what the components of the system are, but not how they are implemented.

### Hypercode (Paradigm)
Definition: Hypercode is a declarative programming paradigm designed to radically separate a program's logical structure from its contextual configuration. It is not a specific language or framework, but a model of development. The core idea is that the abstract flow of a program is defined in one type of file ([[Hypercode (.hc)]]), while the concrete implementations and environment-specific details are provided by another ([[Hypercode Cascade Sheet (HCS)]]).
Related: [[Hypercode (.hc)]], [[Hypercode Cascade Sheet (HCS)]]

### Hypercode Cascade Sheet (HCS)
Definition: Hypercode Cascade Sheet (.hcs file) is a YAML-compatible file that configures the entities defined in a [[Hypercode (.hc)]] file. It uses [[Selector|Selectors]] to target specific commands and apply configuration data. It is analogous to a CSS stylesheet, providing the concrete implementations, data, and behaviors for the abstract structure. It defines how the components work.
Related: [[Hypercode (.hc)]], [[Selector]]

### Hypercode Compliant Certification Program
Definition: is an initiative aimed at creating an ecosystem of compatible tools. Third-party developers can run their runtime implementations through the [[CLI Golden Test Runner]], and if all tests pass, they receive an official "seal of quality" confirming their compatibility with the specification.

### Hypercode Compliant SVG Badge
Definition: The "Hypercode Compliant" SVG badge is an official graphic icon that developers of certified runtimes can place in their repositories to demonstrate their compliance with the specification.

### Hypercode.lock
Definition: file is a manifest, similar to package-lock.json in npm, which contains [[cryptographic hashes]] of all .hcs files used in a project. This file is the basis for the [[HCS Signing & Verification]] mechanism, ensuring configuration integrity.
Related: [[Cryptographic Hashes]], [[HCS Signing & Verification]]

### ID Selector
Definition: An ID Selector targets a single, unique command in a .hc file that has been marked with a specific ID, prefixed with a hash (#). For example, '#primary-db': targets the unique command Database#primary-db. It has the highest [[Specificity]] of the basic selectors.
Related: [[Specificity]]

### Import Cascade
Definition: is the mechanism that determines the order and precedence of rules applied from different .hcs files linked via the [[@import Directive]]. The cascade rules define how styles are merged and overridden if they are specified in multiple files. In Hypercode, rules from the importing (main) file have higher precedence than those from imported files.
Related: [[@import Directive]]

### Incremental Resolution (Hot Reload)
Definition: is an optimization for development (watch mode), where the runtime does not re-calculate the entire configuration graph when a single file changes, but instead identifies and updates only the parts affected by the change. This provides almost instantaneous feedback.

### Integration Tests
Definition: Integration Tests are tests that verify the correct interaction of multiple system components with each other. In Hypercode, this primarily involves running the [[Â«golden fixturesÂ»]].
Related: [[Golden Fixtures]]

### Inter-Process Communication
Definition: IPC (Inter-Process Communication) is a set of mechanisms that allow different processes (e.g., an IDE and the Hypercode runtime) to exchange data. The [[Stable ABI/IPC Contract]] standardizes this interaction.
Related: [[Stable ABI/IPC Contract]]

### Interpolation
Definition: Interpolation is the process of substituting placeholders in a [[Hypercode Cascade Sheet (HCS)]] file with dynamic values at runtime. The most common use is [[Environment Variable Expansion]] (e.g., `host: "${DB_HOST}"`), but it can also extend to other values within the [[Execution Context]]. A formal definition of interpolation syntax and the available scope of values is critical for predictable configuration and for tooling like the [[HCS Linter]].
Related: [[Environment Variable Expansion]], [[Execution Context]], [[HCS Linter]], [[Hypercode Cascade Sheet (HCS)]]

### Invariance Guarantees
Definition: are a set of statements in the [[Resolution Semantics]] that describe which properties of the system remain unchanged during the resolution process. For example, an invariant might be that the order of components in an .hc file does not affect rule application, unless order-based combinators are used in the selectors.
Related: [[Resolution Semantics]]

### JIT (just-In-Time) Code
Definition: â in the context of Hypercode, this refers to the standard execution model where the runtime reads and interprets .hcs files "on the fly" every time the application starts. This provides maximum flexibility but creates [[JIT startup overhead]]. The opposite is [[AOT code]].
Related: [[AOT Code]], [[JIT Startup Overhead]]

### JIT Startup Overhead
Definition: is the extra time a Hypercode application takes to start compared to an equivalent application written in pure imperative code. This overhead is due to the need to parse and resolve .hcs files at every startup. One of the project's goals is to minimize this figure.

### JSON-RPC
Definition: JSON-RPC is a simple remote procedure call protocol that uses JSON to encode messages. It is a candidate for implementing the [[Stable ABI/IPC Contract]] due to its simplicity.
Related: [[Stable ABI/IPC Contract]]

### Killer App
Definition: is a colloquial term for a feature or tool that makes a technology extremely attractive and ensures its success. In the context of Hypercode, the [[Configuration Inspector]] is intended to be this "killer app," as it solves the main problem of declarative cascade systems: the difficulty of debugging.

### Kubernetes
Definition: Kubernetes is an open-source platform for automating the deployment, scaling, and management of containerized applications.

### Kubernetes: Configmap, Secret
Definition: ConfigMap and Secret are standard resources in [[Kubernetes]] for storing configuration data and secrets, respectively. A Kubernetes generator in Hypercode allows for the automatic creation of these resources based on .hcs rules.
Related: [[Kubernetes]]

### Language Server Protocol (LSP)
Definition: is a standard created by Microsoft that defines the protocol for interaction between a code editor (IDE) and a "language server." The server provides features such as autocompletion, diagnostics, and formatting. Creating a single LSP server for Hypercode makes it easy to integrate language support into multiple editors (VS Code, JetBrains IDEs, etc.).

### Language-Agnostic
Definition: Language-agnostic is a property of a system or standard that allows it to work with components written in different programming languages. Hypercode aims to be a language-agnostic orchestration layer.

### List Merge Strategy
Definition: The List Merge Strategy is a specific rule within the [[Property Merge Strategy]] that defines how array properties are combined when a component is targeted by multiple rules. Developers can specify a policy for merging, such as:
Related: [[Property Merge Strategy]]

### List Of Certified Runtimes
Definition: The List of Certified Runtimes is an official, public list on the project's website that serves as a directory of all third-party implementations that have passed the [[Certification Process]].
Related: [[Certification Process]]

### Live Validation
Definition: is an IDE feature that checks code for errors as it is being written and immediately underlines problem areas, without waiting for compilation or execution.

### Main Cascade Resolution
Definition: is the key process in the Hypercode runtime during which it collects all rules from all .hcs files, sorts them according to specificity and order, and then sequentially applies them to the components from the .hc file to determine their final properties.

### Mandatory Requirement
Definition: A mandatory requirement â in the context of the roadmap, this means that a task or condition is non-negotiable and must be fulfilled for the successful completion of a stage.

### Map Merge Strategy
Definition: The Map Merge Strategy is a component of the [[Property Merge Strategy]] that defines how map/dictionary properties are combined. The strategy must clarify whether the merge is shallow (top-level keys are replaced) or deep (nested maps are recursively merged). The default behavior in Hypercode is typically a deep merge, allowing for granular configuration overrides, while key collisions at the same level are resolved based on [[Document Order]].
Related: [[Document Order]], [[Property Merge Strategy]]

### Mathematical Model
Definition: is a way of formalizing the [[Resolution Semantics]] using mathematical apparatus (e.g., set theory or graph theory). Creating such a model is the ultimate goal for achieving complete unambiguity in the specification.
Related: [[Resolution Semantics]]

### Merge Gate
Definition: A Merge Gate is a rule in a version control system that prohibits merging a branch (e.g., a Pull Request) if the [[CI/CD pipeline]] for it has not completed successfully. This is a mandatory requirement for maintaining the quality of the main branch.
Related: [[CI/CD Pipeline]]

### Mixins/templates
Definition: are a mechanism in HCS that allows defining reusable blocks of configuration and "mixing" them into different rules. This is the primary tool for following the [[DRY (Don't Repeat Yourself)]] principle in .hcs files.
Related: [[DRY (Don't Repeat Yourself)]]

### Namespace
Definition: A Namespace is a conceptual scope that prevents name collisions for identifiers (IDs) and classes within a large project. While [[Hypercode (.hc)]] does not have a formal namespace syntax, the [[@import Directive]] and file structure implicitly create them. A robust [[Resolution Algorithm]] must define how [[ID Selector]] and [[Class Selector]] targets are resolved within the context of their file and the broader [[Import Cascade]] to prevent ambiguity in complex systems.
Related: [[@import Directive]], [[Class Selector]], [[Hypercode (.hc)]], [[ID Selector]], [[Import Cascade]], [[Resolution Algorithm]]

### Official Language Specification
Definition: is the document ([[formal specification]]) that serves as the single source of truth for how the Hypercode language should work. The [[CLI Golden Test Runner]] verifies runtimes against this specification.
Related: [[Formal Specification]]

### Overly-Specific Selectors
Definition: are an anti-pattern in .hcs where a selector becomes too long and fragile (e.g., app > panel > section > button). The [[HCS Linter]] should detect and warn about such selectors, as they complicate maintenance and style overrides.
Related: [[HCS Linter]]

### Passport
Definition: is the declarative manifest of a component, which is the central element of the [[Agent Passport security model]].
Related: [[Agent Passport Security Model]]

### Pluggable Rule Architecture
Definition: is a design for the [[HCS Linter]] that allows users or third-party developers to easily add their own validation rules without modifying the linter's core code. This makes the tool flexible and extensible.
Related: [[HCS Linter]]

### Polyglot Ecosystem
Definition: A polyglot ecosystem is the community and set of tools around a technology that support and encourage development in different programming languages. Creating such an ecosystem is one of Hypercode's strategic goals.

### Pre-Processing Step
Definition: A pre-processing step is a stage in the runtime's operation that is executed before the main rule resolution process. At this stage, the runtime processes constructs like [[Mixins/Templates]], effectively substituting their content into the appropriate places before the [[main cascade resolution]] begins.
Related: [[Main Cascade Resolution]], [[Mixins/templates]]

### Property Merge Strategy
Definition: is the set of rules that defines how a component's properties are combined when it is targeted by multiple non-conflicting rules. For example, if one rule sets port and another sets host, the component will end up with both properties.

### Property Provenance Trace
Definition: A Property Provenance Trace is the detailed "chain of custody" for a component's final property value, as displayed by the [[Configuration Inspector]]. It provides a step-by-step history showing every rule that targeted the property, the file and line number of each rule, their [[Specificity]] scores, and which rule ultimately "won" the cascade. This trace is the core data that powers the inspector's [[Explain Mode]] and [[âStylesâ Panel]].
Related: [[Explain Mode]], [[Specificity]], [[Styles Panel]]

### Quality Standard
Definition: A quality standard is a set of formal requirements and tests (e.g., [[Â«golden fixturesÂ»]]) that any implementation must meet to be considered high-quality and compliant.
Related: [[Golden Fixtures]]

### Quick-Fixes
Definition: are automatic actions suggested by the IDE to correct detected errors or linter warnings. For example, if the linter finds a duplicated block of code, it might suggest a "quick-fix" to extract it into a [[Mixins/Templates]].
Related: [[Mixins/templates]]

### Read-Only Access
Definition: is a security principle applied to [[@expression]]. It means that expressions can only read values from the context (e.g., environment variables) but cannot modify them. This prevents side effects and preserves the declarative nature of the configuration.
Related: [[@expression]]

### Real-World Workloads
Definition: are scenarios for benchmarking that simulate the use of Hypercode in actual, complex projects, rather than in simple synthetic tests. They include a large number of components, imports, and complex rules, which allows for a realistic performance evaluation.

### Reference Runtime
Definition: is the main, official implementation of the Hypercode execution environment. It serves as the standard against which all other (potentially third-party) implementations should be compared. The reference runtime is responsible for parsing .hc and .hcs files, applying the [[import cascade]], resolving rules, and ultimately, assembling and running the application.
Related: [[Import Cascade]]

### Relative And Absolute Paths
Definition: are two ways of specifying file locations when using the [[@import Directive]]. Absolute paths specify the full path from the file system's root, while relative paths specify the path from the location of the current .hcs file. Supporting both path types is important for project organization flexibility.
Related: [[@import Directive]]

### Resolution Algorithm
Definition: The Resolution Algorithm is the process performed by the [[reference runtime]] to determine the final configuration of every component. It involves parsing the .hc and .hcs files, resolving the applicable [[@rules]] based on the [[Execution Context]], and then merging properties based on [[Cascade and Specificity]].
Related: [[@rules]], [[Cascade And Specificity]], [[Execution Context]], [[Reference Runtime]]

### Resolution Cache
Definition: The Resolution Cache is an in-memory store used to support [[Incremental Resolution (Hot Reload)]]. When operating in [[Watch Mode]], the runtime uses this cache to store the results of previous resolutions (e.g., the [[AST (Abstract Syntax Tree)|AST]] or partially resolved graphs). When a file changes, the runtime can invalidate only the affected parts of the cache, recalculating a small subset of the graph instead of starting from scratch. This dramatically speeds up reload times in development.
Related: [[AST (Abstract Syntax Tree)]], [[Incremental Resolution (Hot Reload)]], [[Watch Mode]]

### Resolution Overhead
Definition: is the time the runtime spends on the [[main cascade resolution]]. It is the main component of the [[JIT startup overhead]].
Related: [[JIT Startup Overhead]], [[Main Cascade Resolution]]

### Resolution Semantics
Definition: is the formal, mathematically precise description of the entire [[main cascade resolution]] process. It includes the [[selector specificity calculation algorithm]], the [[property merge strategy]], and the [[conflict resolution rules]], and also provides [[determinism]] and [[invariance guarantees]]. It is the most important part of the specification for ensuring runtime compatibility.
Related: [[Conflict Resolution Rules]], [[Determinism]], [[Invariance Guarantees]], [[Main Cascade Resolution]], [[Property Merge Strategy]], [[Selector Specificity Calculation Algorithm]]

### Resolved Configuration Graph
Definition: is the final data structure that the runtime creates after applying all .hcs rules to the .hc file. This graph represents a complete description of all application components and their final, configured properties. This graph is the input for the [[Configuration Inspector]].

### Rule Importance
Definition: Rule Importance is a mechanism that allows a single rule to override all other declarations, regardless of [[Specificity]] or [[Document Order]]. It is the equivalent of CSS's `!important` flag. Using importance should be done sparingly, as it can make debugging the cascade more difficult. Its primary purpose is for user override stylesheets or critical security policies that must not be accidentally overridden. It is the highest layer of the [[Cascade and Specificity]] hierarchy, even above [[Rule Origin]].
Related: [[Cascade And Specificity]], [[Document Order]], [[Rule Origin]], [[Specificity]]

### Rule Origin
Definition: Rule Origin refers to the source layer from which a configuration rule originates. The [[Resolution Algorithm]] uses origin as the first and most critical step in the [[Cascade and Specificity]] calculation, creating a layered system of precedence. The standard origins are, in increasing order of priority:
Related: [[@import Directive]], [[Cascade And Specificity]], [[Import Cascade]], [[Resolution Algorithm]]

### Runner
Definition: A Runner is the component of the [[Reference Runtime]] responsible for interpreting and executing a Hypercode application in [[JIT (Just-In-Time) code|JIT mode]]. It performs the file parsing, rule resolution, and construction of the [[Executable Program Graph]] every time the application starts. This term helps distinguish the interpretation-based execution model from the pre-compiled [[AOT (Ahead-Of-Time) Compilation|AOT]] model.
Related: [[AOT (ahead-Of-Time) Compilation]], [[Executable Program Graph]], [[JIT (just-In-Time) Code]], [[Reference Runtime]]

### Runtime Contract (Interface)
Definition: is a formal description of how external code (e.g., a factory for [[@factory]]) must interact with the Hypercode runtime. This contract defines what methods and data the runtime provides to the factory (e.g., access to other dependencies) and what the factory must return as a result.
Related: [[@factory]]

### Runtime Parsing
Definition: is the process of reading and analyzing .hcs files that occurs every time the application starts in [[JIT code]] mode. [[AOT (Ahead-Of-Time) Compilation]] eliminates the need for this step.
Related: [[AOT (ahead-Of-Time) Compilation]]

### Safe, Sandboxed Expression Evaluator
Definition: is a runtime component that executes the code written in [[@expression]] directives. "Sandboxed" means that this code has no access to the file system, network, or other potentially dangerous resources. It can only work with the data explicitly provided to it.
Related: [[@expression]]

### Sass/scss
Definition: is a preprocessor for CSS that extends its syntax by adding features like variables, nesting, and mixins. It is mentioned in Hypercode as a source of inspiration for the implementation of [[Mixins/Templates]], as it solves a similar problem of duplication in declarative styling languages.
Related: [[Mixins/templates]]

### Secret:// URI Scheme
Definition: is a standardized way of referencing secrets from .hcs files that avoids storing them directly in the code. The URI specifies where to load the secret from (e.g., secret://vault/path/to/key). This URI is handled by the [[SecretProvider model]].
Related: [[Secretprovider Model]]

### Secretprovider Model
Definition: is a pluggable architecture in the runtime that allows connecting different "providers" to work with various secret stores (HashiCorp Vault, AWS Secrets Manager, etc.). The runtime delegates the task of retrieving a secret to the provider based on the address specified in the [[secret:// URI scheme]].
Related: [[Secret:// URI Scheme]]

### Secure Mode
Definition: is a special operating mode for the runtime in which it requires mandatory verification of the hypercode.lock file's digital signature before execution. In this mode, any unsigned or tampered configuration will be rejected.

### Secure-By-Design
Definition: is a development approach where security considerations are an integral part of the architecture from the very beginning, rather than being added on at the end. Hypercode aims to follow this principle by building security into the core of the language and runtime.

### Security Capability Checks
Definition: are a requirement for the [[AOT compiler]], stating that it must embed the same security checks (see [[Capability Enforcement in Resolution Engine]]) into the generated [[AOT code]] that the runtime performs in JIT mode. This ensures that compiled code is as secure as interpreted code.
Related: [[AOT Code]], [[AOT Compiler]], [[Capability Enforcement In Resolution Engine]]

### Security Policy
Definition: is a set of rules that defines what is allowed and what is forbidden for the components of a system. In Hypercode, the security policy is defined using the [[Agent Passport security model]] and is enforced by the runtime.
Related: [[Agent Passport Security Model]]

### Security Policy Gating
Definition: is a requirement that the use of potentially powerful features like [[Declarative Escape Hatches]] must be explicitly enabled in the runtime configuration. By default, they are disabled to prevent accidental or malicious execution of unsafe code.
Related: [[Declarative Escape Hatches]]

### Security Sandbox Wrappers
Definition: Security sandbox wrappers are a requirement for the implementation of the [[Â«Adapter for Legacy CodeÂ» Pattern]], according to which the adapter class should not only transform the interface but also, where possible, restrict (sandbox) the legacy code to prevent it from gaining unauthorized access to resources.
Related: [[Adapter For Legacy Code Pattern]]

### Security Scanning
Definition: Security Scanning is a part of the [[CI/CD pipeline]] where automated tools check the code and its dependencies for known vulnerabilities.
Related: [[CI/CD Pipeline]]

### Selector
Definition: A Selector is the mechanism used in a [[Hypercode Cascade Sheet (HCS)]] to target elements within a [[Hypercode (.hc)]] file. The RFC defines several types of selectors, which are applied based on a [[Specificity]] algorithm to resolve which configuration takes precedence.
Related: [[Child Selector]], [[Class Selector]], [[Hypercode (.hc)]], [[Hypercode Cascade Sheet (HCS)]], [[ID Selector]], [[Specificity]], [[Type Selector]]

### Selector Specificity Calculation Algorithm
Definition: is a formal set of rules that determines which selector is "more important" or "more precise." The runtime uses this algorithm to decide which of the conflicting rules to apply. For example, an ID selector (#my-id) is typically more specific than a class selector (.my-class).

### Semantic Autocompletion
Definition: Semantic autocompletion is an advanced IDE feature that suggests code completion options based not only on syntax but also on the meaning (semantics) of the entire project. For example, when writing a selector in .hcs, the IDE will suggest the names of components that actually exist in the .hc file.

### Semantic Versioning (SemVer)
Definition: Semantic Versioning (SemVer) is a formal standard for assigning version numbers to software. It prescribes how to change the version number (MAJOR.MINOR.PATCH) depending on whether the changes are breaking. The [[Stable ABI/IPC Contract]] must strictly follow this standard.
Related: [[Stable ABI/IPC Contract]]

### Separation Of Concerns
Definition: Separation of Concerns is a core design principle that Hypercode aims to maximize. It refers to the practice of separating a program into distinct sections, where each section addresses a separate concern. Hypercode enforces a radical separation between the logical structure (the "what," defined in .hc) and the contextual configuration (the "how," defined in .hcs).

### Specificity
Definition: Specificity is the weight or importance that the [[Resolution Algorithm]] gives to a [[Selector]]. It is calculated based on the components of the selector (number of IDs, classes, and types). This calculation is fundamental to ensuring a predictable and deterministic outcome when multiple rules target the same component.
Related: [[Resolution Algorithm]], [[Selector]]

### Stable ABI/IPC Contract
Definition: A Stable ABI/IPC Contract is a formalized and versioned protocol that defines how the Hypercode ecosystem tools (IDE, CLI) interact with the runtime. The stability of this contract is critical for the [[language-agnostic]] approach.
Related: [[Language-Agnostic]]

### Static Analysis
Definition: Static Analysis is the analysis of code without actually executing it. In Hypercode, this includes the work of the [[HCS Linter]] and other tools that look for potential errors, vulnerabilities, and style violations.
Related: [[HCS Linter]]

### Steep Learning Curve
Definition: is a characteristic of a technology that requires significant effort and time to master. Hypercode, as a new paradigm, potentially has this characteristic. The DX section of the roadmap aims to "flatten" this curve with intuitive tools and quality documentation.

### Styles Panel
Definition: is a user interface element in the [[Configuration Inspector]] that mimics the analogous panel in web browser developer tools. It conveniently displays all rules applied to the selected component and allows for interactive exploration of the cascade.

### Syntax Highlighting
Definition: is a basic IDE feature that colors different parts of the code (keywords, strings, comments) differently, improving readability. It is one of the first tasks when implementing language support in an editor.

### Terraform
Definition: Terraform is a popular tool for managing infrastructure as code (IaC).

### Terraform: .tfvars
Definition: .tfvars are variable files for [[Terraform]], a tool for managing infrastructure as code. A Terraform generator in Hypercode allows infrastructure variables to be managed from the same .hcs files as the application.
Related: [[Terraform]]

### Type Selector
Definition: A Type Selector is the most basic form of [[Selector]] in HCS. It targets a command or entity based on its name (its type). For example, a selector Database: targets all Database commands in the corresponding .hc file. It has the lowest [[Specificity]].
Related: [[Selector]], [[Specificity]]

### Unit Tests
Definition: Unit Tests are tests that verify the correctness of the smallest, isolated parts of the code (modules, functions).

### Unreferenced Secrets
Definition: are a potential security issue where a value exists in a secret store, but no rule in .hcs references it. The [[HCS Linter]] can integrate with secret management systems to detect such "dangling" data.
Related: [[HCS Linter]]

### Version Compatibility Testing
Definition: Version Compatibility Testing is a process that ensures a new version of the runtime is backward compatible with configurations written for previous versions, in accordance with [[Semantic Versioning (SemVer)]] rules.
Related: [[Semantic Versioning (SemVer)]]

### Versioning Scheme
Definition: The Versioning Scheme is the formal policy that dictates how the [[Official Language Specification]] and its associated tools and runtimes are versioned. This scheme must strictly adhere to [[Semantic Versioning (SemVer)]] to ensure predictability and maintain a stable ecosystem. Major version changes signal breaking changes to the specification or the [[Stable ABI/IPC Contract]] , while minor and patch versions guarantee backward compatibility, as verified by [[Version Compatibility Testing]] .
Related: [[Official Language Specification]], [[Semantic Versioning (SemVer)]], [[Stable ABI/IPC Contract]], [[Version Compatibility Testing]]

### Watch Flag
Definition: is a command-line flag for starting the Hypercode runtime in [[watch mode]].
Related: [[Watch Mode]]

### Watch Mode
Definition: is an operating mode for the runtime in which it monitors .hc and .hcs files for changes and automatically reloads the configuration upon saving them, using [[Incremental Resolution (Hot Reload)]].
Related: [[Incremental Resolution (Hot Reload)]]

### Wildcard Selectors
Definition: are selectors that use `*` to target all components. Their use can be dangerous because they have low specificity but can unintentionally change the configuration of a large number of components. The [[HCS Linter]] should warn about such usage.
Related: [[HCS Linter]]

### WIT (WebAssembly Interface Types)
Definition: WIT (WebAssembly Interface Types) is a standard for describing interfaces between WebAssembly components and the host system. It is a promising candidate for the [[Stable ABI/IPC Contract]] due to its focus on security and language independence.
Related: [[Stable ABI/IPC Contract]]

### YAML Hell
Definition: is a colloquial term describing a situation where configuration files in YAML format (or similar, like .hcs) become so large, nested, and complex that they are impossible to read, maintain, and debug. Hypercode combats this phenomenon with modularization mechanisms like [[@import Directive]] and [[Mixins/Templates]].
Related: [[@import Directive]], [[Mixins/templates]]
