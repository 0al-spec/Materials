# TODO-список для расширения RFC языка Hypercode

Этот документ представляет собой план работ по развитию языка Hypercode и его экосистемы. Он основан на "открытых вопросах" из первоначального RFC и выводах из сравнительного анализа с существующими DI-фреймворками и IaC-инструментами.

## Раздел 1: Расширение ядра языка и синтаксиса HCS

Цель этого раздела — увеличить выразительность языка HCS, чтобы управлять сложностью конфигураций и преодолеть "декларативный обрыв".

 * [ ] 1.1. Внедрить директиву @import
   * Описание: Добавить возможность импортировать один .hcs файл в другой. Это ключевая функция для управления сложностью, позволяющая разбивать монолитные конфигурации на переиспользуемые модули (например, database.hcs, logging.hcs).
   * Источник: RFC (раздел "Open Questions"), Сравнительный анализ (риск "YAML hell").
 * [ ] 1.2. Определить "Декларативные лазейки" (Declarative Escape Hatches)
   * Описание: Исследовать и определить синтаксис для случаев, когда логика конфигурации слишком сложна для чистого DSL. Возможные варианты:
     * @factory: ссылка на функцию или класс-фабрику в коде, который будет отвечать за создание компонента.
     * @expression: возможность выполнить простое выражение для вычисления значения свойства.
   * Источник: Сравнительный анализ (проблема "Декларативный обрыв").
 * [ ] 1.3. Расширить синтаксис селекторов
   * Описание: Добавить более мощные селекторы, аналогичные продвинутым CSS-селекторам, для более точного таргетинга. Например:
     * Селекторы по атрибутам (WebServer[secure=true]).
     * Селекторы соседних (Logger + WebServer) и дочерних (>) элементов.
   * Источник: Необходимость повышения гранулярности конфигурации.
 * [ ] 1.4. Разработать концепцию "миксинов" или "шаблонов"
   * Описание: Создать механизм для определения переиспользуемых блоков конфигурации, которые можно "подмешивать" к разным селекторам, чтобы избежать дублирования кода (аналог @mixin в Sass/SCSS).
Раздел 2: Инструментарий и опыт разработчика (Developer Experience)
Цель — снизить порог вхождения и сделать повседневную работу с Hypercode продуктивной и безопасной. Это самый критичный раздел для успешного внедрения.
 * [ ] 2.1. Создать "Инспектор конфигурации"
   * Описание: Разработать инструмент (CLI или GUI), который для любого компонента в собранном приложении покажет:
     * Какие .hcs правила к нему применились.
     * В каком порядке (каскад).
     * Какое правило установило финальное значение для каждого свойства и какие значения были переопределены.
   * Источник: RFC (раздел "Debugging and Tooling"), Сравнительный анализ (раздел "Незрелость инструментов и отладки").
 * [ ] 2.2. Разработать плагины для IDE (VS Code, JetBrains)
   * Описание: Обеспечить базовую поддержку в популярных редакторах: подсветка синтаксиса, автодополнение для селекторов и свойств, валидация .hc и .hcs файлов, переход к определению.
 * [ ] 2.3. Создать визуализатор графа приложения
   * Описание: Инструмент, который на основе .hc файла строит и отображает визуальную диаграмму архитектуры, показывая компоненты и их иерархию.
   * Источник: Сравнительный анализ (раздел "Критическая важность экосистемы инструментов").
 * [ ] 2.4. Разработать Линтер для .hcs файлов
   * Описание: Автоматизированный анализатор, который проверяет .hcs файлы на соответствие лучшим практикам (например, запрет на слишком сложные селекторы, ограничение глубины вложенности) для предотвращения "YAML-ада".
Раздел 3: Производительность и модель исполнения
Цель — проанализировать и минимизировать накладные расходы на запуск приложения.
 * [ ] 3.1. Провести бенчмаркинг производительности
   * Описание: Измерить накладные расходы на парсинг и разрешение каскада правил при старте приложения для разных уровней сложности конфигурации.
   * Источник: RFC (раздел "Performance").
 * [ ] 3.2. Исследовать AOT-компиляцию (Ahead-Of-Time)
   * Описание: Разработать механизм, который может "скомпилировать" связку .hc + .hcs в оптимизированный императивный код на целевом языке (например, в Java-класс с Guice-модулем или Python-скрипт), устраняя оверхед в рантайме.
Раздел 4: Безопасность
Цель — определить стандартные и безопасные практики работы с чувствительными данными.
 * [ ] 4.1. Стандартизировать управление секретами
   * Описание: Четко определить в спецификации, как .hcs файлы должны работать с секретами (пароли, API-ключи). Это должно включать нативный синтаксис для ссылок на внешние хранилища (например, value: "secret://vault/path/to/db-password").
   * Источник: Сравнительный анализ (раздел "Управление секретами").
 * [ ] 4.2. Исследовать подпись и верификацию конфигураций
   * Описание: Добавить в спецификацию возможность цифровой подписи .hcs файлов, чтобы runtime мог проверить их целостность и происхождение перед применением.
   * Источник: RFC (раздел "Security Considerations").
Раздел 5: Документация и сообщество
Цель — создать базу знаний и набор практик для облегчения изучения и внедрения Hypercode.
 * [ ] 5.1. Написать исчерпывающие руководства и туториалы
   * Описание: Создать пошаговые руководства для типовых задач: "Создание веб-сервиса", "Конфигурация AI-пайплайна", "Миграция с Spring".
 * [ ] 5.2. Сформулировать и опубликовать "Лучшие практики"
   * Описание: Разработать официальный гайд по именованию селекторов, структурированию .hcs файлов в больших проектах и решению типичных архитектурных задач.
   * Источник: Сравнительный анализ (раздел "Построение сообщества").
Раздел 6: Интеграция и совместимость
Цель — определить, как Hypercode взаимодействует с существующими системами и кодом.
 * [ ] 6.1. Определить паттерн "Адаптер для Legacy-кода"
   * Описание: Описать в документации официальный паттерн для интеграции с кодом, который не следует принципам DI (например, использует синглтоны). Это включает создание "оберток", которые скрывают "нечистоту" legacy-кода.
   * Источник: Сравнительный анализ (раздел "Интеграция с существующими (legacy) системами").
 * [ ] 6.2. Расширить раздел "Compatibility and Interoperability" в RFC
   * Описание: Детализировать, как Hypercode может генерировать конфигурации для других систем, например, terraform.tfvars или манифесты Kubernetes, превращаясь в единый источник правды для конфигурации не только приложения, но и его окружения.