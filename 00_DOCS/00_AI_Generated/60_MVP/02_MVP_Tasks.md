Вот полный подробный breakdown всех задач с пояснениями, собранный по всем ранее уточнённым и проработанным разделам -- в соответствии с новой структурой PRD:

⸻

Agentification Layer -- Полный список задач с пояснениями (Waterfall)

⸻

ФАЗА A -- ОКРУЖЕНИЕ И ИНФРАСТРУКТУРА

⸻

A.1. Подготовка к запуску (Docker + systemd)

1. Напиши systemd unit-файл для запуска agentifyd.js
	•	Позволяет запускать agentifyd как постоянный фоновый сервис.
	•	Обеспечивает автостарт, логирование, рестарты, удобен для DevOps.

2. Обеспечь создание сокета /run/agentifyd.sock с правами
	•	Это главный IPC-механизм, через который всё взаимодействие происходит.
	•	Ошибки прав доступа могут полностью сломать работу демона.

3. Протестируй ручной запуск и запуск через systemd
	•	Нужно убедиться, что демон работает одинаково в dev и prod режимах.
	•	Помогает быстрее отлаживать и катить исправления.

4. Подготовь docker-compose с volume для passports/
	•	Эмулирует production-среду прямо на macOS через Linux-контейнер.
	•	Упрощает деплой, совместим с CI, не требует systemd.

5. Напиши README.md с установкой и вызовами
	•	Первый документ для пользователя и разработчика.
	•	Позволяет воспроизвести систему без лишних вопросов.

⸻

A.2. Подготовка среды разработки (DevContainer)

1–3. Установи Docker Desktop, VS Code и создай .devcontainer
	•	Обеспечивает совместимую Linux-среду, даже если ты на macOS.
	•	Помогает избежать ошибок типа «у меня всё работает, а в проде нет».

4. Инициализируй Node.js проект
	•	npm init -y + структура файлов создаёт стартовую точку проекта.

5. Добавь зависимости: express, grpc, dotenv, js-yaml
	•	Это базовые библиотеки, на которых работает весь демон.
	•	Без них невозможно реализовать HTTP, gRPC и загрузку паспортов.

⸻

A.3. Документация и walkthrough

1. Задокументируй структуру YAML-паспорта
	•	Помогает писать агентов и валидировать структуру.
	•	Является основой future WebUI/редактора паспортов.

2. Оформи Swagger / OpenAPI для MCP /invoke
	•	Делает внутренний интерфейс доступным и понятным.
	•	Упростит автоматическое тестирование и UI-интеграции.

3. Опиши A2A .proto + документацию вызовов
	•	A2A -- публичный интерфейс системы. .proto нужен для генерации клиентов.

4. Напиши архитектурное описание (markdown + схемы)
	•	Позволяет быстро объяснить другим, как всё устроено.

5. Проведи ручной walkthrough + TODO.md
	•	Фиксирует реальные баги, недочёты и упрощает планирование следующего этапа.

⸻

ФАЗА B -- ФУНКЦИОНАЛЬНАЯ РЕАЛИЗАЦИЯ

⸻

B.1. Парсер YAML-паспортов

1. Создай директорию passports/ и добавь тестовый YAML
	•	Это источник декларативного описания агентов.

2. Реализуй модуль passportLoader.js
	•	Отвечает за чтение и парсинг паспортов в память.
	•	Делает структуру доступной остальной системе.

3. Определи и проверь структуру агента
	•	id, tools, cmd, caps -- всё это валидируется.
	•	Ошибки структуры должны логироваться и не ломать остальную систему.

4. Добавь логирование и защиту от сломанных YAML
	•	Позволяет безопасно загружать частично повреждённые декларации.

⸻

B.2. MCP-исполнитель (внутренний Unix-сервер)

1. Реализуй JSON-RPC MCP сервер на express через Unix socket
	•	Главная точка приёма запросов от A2A-прокси.

2. Настрой /invoke endpoint с POST
	•	Принимает: agent_id, tool, args.

3. Имплементируй child_process.spawn с подстановкой аргументов
	•	Запускает shell-команды из декларации агента.

4. Реализуй проверку caps: доступ к пути, типы команд
	•	Без этого агент может выполнить любую команду -- что небезопасно.

5. Стриминг stdout/stderr
	•	Возвращает результат исполнения клиенту, включая ошибки.

6. Добавь логирование вызовов
	•	Фиксирует исполнение команд, trace_id, статусы -- важно для аудита.

⸻

B.3. A2A Discovery и Server (gRPC)

1. Подключи и опиши a2a.proto (submitGoal, streamResult)
	•	Это внешний интерфейс всей системы.

2. Сгенерируй серверные биндинги
	•	Через @grpc/proto-loader подключи a2a.proto к Node.js

3. Запусти gRPC сервер и обработай submitGoal
	•	Проксирует вызов в MCP и возвращает результат.

4. Обработай streamResult через duplex поток
	•	Позволяет стримить stdout агента напрямую в gRPC клиента.

5. Добавь логирование и поддержку trace_id
	•	Без trace невозможно отследить, что произошло между слоями.

⸻

B.4. Реестр агентов и hot-reload

1. Реализуй agentRegistry.js как кэш паспортов
	•	Позволяет быстро находить агента по ID.

2. Загружай YAML при старте и логируй их
	•	Агент должен быть доступен без ручной регистрации.

3. Определи поведение при ошибках, отсутствующем агенте
	•	Например, 404 Agent Not Found вместо падения.

4. Реализуй hot-reload при изменении .yaml на диске
	•	Позволяет обновлять агента без перезапуска всей системы.

⸻

B.5. Безопасность и изоляция

1. Проверь доступ к путям по caps
	•	Разрешение команд должно быть жёстко ограничено.

2. Добавь whitelist допустимых команд
	•	Бинарей типа rm, curl и shutdown быть не должно.

3. sandbox: отключи shell, очисти env, настрой spawn
	•	Снижаем риск инъекций и повышения привилегий.

4. Протестируй защиту от опасных YAML/команд
	•	Явно проверь, что rm -rf / не проходит.

5. Подготовь план усиления: seccomp, chroot, namespaces
	•	Не делаем сейчас, но готовим почву на следующий спринт.

⸻

B.6. Логирование и трассировка

1. Создай logger.js с форматами INFO, WARN, ERROR
	•	Единообразные логи -- это основа debug’а.

2. Логируй каждый вызов MCP и A2A
	•	Обязательно фиксируй: agent_id, tool, args, status.

3. Прокидывай trace_id по всей цепочке
	•	Без него невозможно отследить сложный вызов.

4. Убедись, что всё уходит в stdout
	•	Совместимо с journald, Docker и k8s logs.

⸻

B.7. Интеграция и тестирование

1. Напиши CLI agentctl.js для ручных MCP-вызовов
	•	Используется для отладки и интеграции.

2. Реализуй A2A тест-клиент на grpc.Client
	•	Проверка: submitGoal, streamResult, недоступный агент.

3. Проведи e2e: A2A → MCP → shell → stdout
	•	Это финальный тест жизнеспособности системы.

4. Проверь edge-кейсы: ошибки YAML, shell, пустой output
	•	Без этого нельзя утверждать, что система устойчива.

5. Сохрани тесты в tests/e2e/ с эталонными результатами
	•	Это заготовка для CI и автоматической валидации.
