# Анализ взаимодействия AIOS с операционной системой

## Использование системных утилит (os, subprocess, shutil, pathlib)

AIOS активно использует стандартные модули Python для взаимодействия с ОС. В коде широко применяется модуль os для управления путями, переменными окружения и каталогами. Например, система загружает API-ключи из переменных окружения через вызовы вроде os.getenv (или вспомогательные функции) для внешних сервисов . Также для создания каталогов используется os.makedirs(): в модуле файловой системы AIOS (LSFS) при монтировании хранилища или создании директорий вызывается os.makedirs(dir_path) .

### Пример
Функция sto_create_directory в подсистеме хранения вызывает os.makedirs(dir_path) для создания нового каталога на диске . Аналогично, при чтении/записи файлов используются конструкции with open(...) as f для работы с файловым содержимым .

Модуль pathlib также может применяться для удобного управления путями (в репозитории упоминаются пути конфигурации и хранилищ, что подразумевает использование Path-подобных объектов), однако основная логика реализована через os.path и os напрямую. Прямое использование subprocess в кодовой базе встречается реже – ядро AIOS старается выполнять операции с помощью Python-библиотек. Тем не менее, в некоторых случаях внешние утилиты могут вызываться. Например, отправка команд ollama (для локального LLM-бэкенда) требует запущенного сервера Ollama; вместо прямого вызова subprocess разработчики настраивают клиент для подключения к сервису (см. ниже про сетевые взаимодействия). В скриптах установки/запуска возможны вызовы команд (например, установка зависимостей, запуск Docker), но внутри основного исполняемого кода AIOS прямой запуск системных команд минимален.

Стоит отметить, что модуль shutil вероятно используется для операций копирования/перемещения файлов в функциях sto_share или sto_rollback (например, копирование файлов в общую папку или откат к предыдущей версии файла). Хотя явных фрагментов с shutil в открытых частях репозитория не видно, по функционалу этих системных вызовов можно предположить их применение. Например, для “отката” файла (rollback) логично сохранение резервной копии и восстановление её, что обычно реализуется через shutil.copy или os.replace.

В целом, AIOS опирается на кроссплатформенные возможности Python: вместо прямого обращения к утилитам ОС, используются библиотеки, обеспечивающие необходимый функционал. Это повышает переносимость — код одинаково работает на Linux, macOS, Windows без специальных ветвлений (в репозитории не замечено условных конструкций по типу ОС).

## Взаимодействие с файловой системой

AIOS рассматривает файловую систему как часть своего “ядра”, предоставляя агентам абстракцию для хранения и доступа к файлам. Встроенный компонент LSFS (LLM Semantic File System) реализует системные вызовы для работы с ФС: создание/удаление каталогов, чтение/запись файлов, монтирование хранилищ и т.п. Каждая операция соответствует функции в коде (prefixed sto_ в AIOS):
	•	Создание каталогов: при монтировании персонального хранилища или создании папки вызывается os.makedirs. Например, при выполнении sto_create_directory система создаёт указанный путь на диске . Код проверяет существование пути и создает вложенные директории при необходимости.
	•	Создание и запись файлов: для записи данных агентом используется стандартный подход: открыть файл в нужном режиме и записать содержимое. Например, with open(file_path, 'w') as f: f.write(data) – подобные конструкции реализованы во внутренней функции sto_write. Перед записью может выполняться резервирование старой версии (для поддержки отката).
	•	Чтение файлов: аналогично, чтение производится через with open(file_path, 'r') as f: content = f.read() . Пример: функция sto_retrieve_file открывает файл в режиме чтения и возвращает содержимое вызывающему агенту.
	•	Откат изменений (rollback): AIOS предоставляет возможность “отменить” последние изменения файла. Судя по функциональности, при каждой записи может создаваться скрытая копия предыдущего состояния (например, файл с суффиксом .bak или версионирование в отдельном хранилище). При откате файл заменяется старой версией. Это, вероятно, реализовано через операции копирования/переименования (os.rename / shutil.move), хотя конкретный код не показан.
	•	Общий доступ к файлам: функция sto_share_file позволяет агенту предоставить файл другим – возможно, копируя его в общий каталог или помечая как доступный извне. Для этого уместно использование shutil.copy (копирование файла в директорию обмена).

Помимо непосредственной работы с файлами, AIOS управляет директориями агентов. При скачивании нового агента из репозитория, система кэширует его код и данные локально. Например, агент example/academic_agent версии 0.0.1 сохраняется в папку agenthub/cache/example/academic_agent/0-0-1/ и оттуда загружается (инициализируется модуль agent.py) . Этот процесс включает создание соответствующих каталогов для автора и имени агента и сохранение файлов (архивов или кода) на диск.

### Пример
Метод download_agent из менеджера агентов загружает архив агента и сохраняет его. После скачивания вызывается запись на диск – вероятно, через open(..., 'wb') для сохранения бинарного содержимого архива, а затем распаковка (например, с помощью shutil.unpack_archive). В стектрейсе видно обращение к кэшу: путь agenthub.cache.example.academic_agent.0-0-1.agent указывает на файл или директорию, созданную для агента .

Отдельно стоит упомянуть механизм “семантической” файловой системы из статьи ICLR2025 (“From Commands to Prompts: LLM-based Semantic File System for AIOS”). Этот компонент (Terminal UI) позволяет взаимодействовать с ФС через языковые команды. В коде он отражается в модуле LSFS: хотя физически используются обычные вызовы ОС (создать папку, открыть файл), запросы могут приходить в виде неявных команд, которые AIOS интерпретирует. Тем не менее, реализация сводится к описанным выше операциям os/open/shutil на уровне Python.

### Вывод
AIOS напрямую читает и записывает файлы, управляет каталогами и осуществляет копирование, опираясь на встроенные возможности Python. Это позволяет абстрагироваться от конкретной ОС – например, os.makedirs и open работают одинаково в Linux и Windows. Прямой доступ к низкоуровневым системным вызовам (типа POSIX syscalls) отсутствует – AIOS действует как прослойка, обеспечивая безопасную работу агентов с файловой системой хоста через контролируемые функции.

## Сетевые взаимодействия (HTTP, сокеты и пр.)

AIOS интегрирует множество функций, требующих сетевого доступа. Кодовая база содержит явные вызовы HTTP API и, вероятно, создание локальных серверов для взаимодействия между компонентами:
	•	Внешние API для инструментов (Tools): AIOS поставляется со встроенным набором “инструментов” для агентов – например, поиск в интернете, получение данных из Wikipedia или арXiv, геолокация (Google Places) и др. Эти инструменты реализованы как классы, выполняющие HTTP-запросы к внешним сервисам. Например, класс BingSearch отправляет запрос к Bing Web Search API: он считывает ключ из переменной окружения BING_SUBSCRIPTION_KEY и выполняет requests.get на URL Bing API с необходимыми параметрами . В приведенном фрагменте кода видно формирование заголовков с ключом и разбор JSON-ответа:
response = requests.get(self.bing_search_url, headers=headers, params=params) … search_results = response.json() .

Аналогично организованы другие инструменты: GooglePlaces вызывает API Google Places (с API-ключом GOOGLE_API_KEY), ArxivTool обращается к arXiv API, WikipediaTool использует либо публичный API Википедии, либо парсит страницы. Каждый такой модуль находится в папке src/tools/online/ и содержит URL сервиса, подготовку HTTP-запроса (с помощью библиотеки requests) и обработку результата . Использование requests в коде подтверждается анализом: это основной способ сетевого взаимодействия, оборачивающий как внешние REST API вызовы, так и локальные HTTP-запросы внутри системы.
	•	Загрузка и распространение агентов: В экосистеме AIOS предусмотрен Agent Hub – центральный репозиторий агентов (компонент AHM – Agent Hub Machine). AIOS Kernel умеет скачивать агенты по запросу. В менеджере агентов (pyopenagi/manager.py) реализован метод download_agent, который отправляет HTTP-запрос на сервис хаба. Например, по умолчанию используется локальный адрес (вероятно, для режима разработки) – в стеке вызовов видно попытку подключения к http://localhost:3000/api/download?author=example&name=academic_agent . Код выглядит так:
response = requests.get(f"{self.base_url}/api/download", params=params) ,

где base_url – URL сервера хранилища агентов. Ответ (файл агента) после получения сохраняется на диск. Этот фрагмент демонстрирует сетевое взаимодействие внутри локальной инфраструктуры: AIOS Kernel выступает клиентом по отношению к сервису хаба. Если хаб запущен на удалённой машине (режим удалённого ядра), base_url будет содержать соответствующий адрес (например, облачный). Таким образом, механизм распространения агентов основан на HTTP и использует библиотеку requests для коммуникации .
	•	Взаимодействие с LLM-бэкендами: Одно из ключевых предназначений AIOS – абстрагировать работу с крупными языковыми моделями. Система поддерживает различные LLM ядра: локальные (HuggingFace, vLLM, Ollama) и облачные (OpenAI GPT, Claude, Gemini и т.д.). В коде это реализовано через унифицированный интерфейс. Например, для vLLM и Ollama AIOS поднимает (или ожидает) локальный сервер, эмулирующий OpenAI API. Документация показывает, что для подключения к vLLM backend используется класс OpenAI с указанием base_url на локальный хост и фиктивным ключом . Это значит, что AIOS не вызывает vLLM библиотеку напрямую, а делает HTTP-запросы к запущенному серверу vLLM по REST-протоколу (совместимому с OpenAI API). Аналогичный подход для Ollama: Ollama предоставляет локальный HTTP endpoint, и AIOS шлет туда запросы (например, http://localhost:11434 – стандартный порт Ollama). Используя официальный SDK OpenAI (или аналоги), AIOS формирует сетевые запросы для локальных моделей.
Для облачных LLM (OpenAI, Anthropic и др.), разумеется, используются сетевые вызовы к соответствующим веб-сервисам. AIOS загружает API-ключи из окружения (например, OPENAI_API_KEY) и через SDK (openai библиотеку) отправляет запросы на удалённые сервисы OpenAI. Это происходит, к примеру, когда агент требует выполнить функцию LLM: ядро AIOS вызывает openai.ChatCompletion.create(...) – внутри что эквивалентно HTTPS-запросу к api.openai.com. Таким образом, весь обмен с LLM-провайдерами – тоже часть сетевой активности AIOS (в коде явно присутствует работа с соответствующими API).
	•	Связь клиентских компонентов: AIOS предусмотрен в различных режимах (локальный, удалённый). В Remote Kernel Mode клиент (AIOS SDK, называемый Cerebrum) общается с ядром по сети. Хотя подробности в репозитории ядра не полностью раскрыты, можно предположить, что ядро предоставляет локальный API-сервер (например, REST API или WebSocket) для приёма команд от удалённого UI/SDK. Косвенно это подтверждается: в issue обсуждалась необходимость “API interfaces” и был план выпустить SDK . Вероятно, ядро может запускать встроенный веб-сервер (возможны признаки использования FastAPI или аналогов – в зависимостях проекта замечены uvicorn, fastapi в других источниках). Например, в папке runtime могут быть компоненты, запускающие UI: Web UI (вероятно, на Streamlit или Gradio) и Terminal UI. Web UI могла быть реализована как веб-сервер, а Terminal UI – через локальный терминал. Если Web UI есть, то AIOS Kernel либо включает в себя FastAPI приложение, либо запускает внешний процесс. Точных ссылок из кода на FastAPI не обнаружено, но это часть анонсированных фич. Тем не менее, сетевая коммуникация между ядром и UI определённо присутствует: как минимум SDK Cerebrum обращается к ядру по HTTP (например, для выполнения системных вызовов – Storage, Tool API и пр., перечисленных в документации).

### Вывод
Сетевые взаимодействия в AIOS обширны. Код напрямую выполняет HTTP-запросы как вовне (к сторонним API, облачным LLM), так и внутри (между компонентами AIOS). В репозитории видны явные примеры – использование библиотеки requests для вызова внешних сервисов (Google, Bing, арXiv и др. ) и для загрузки агентов через локальный REST API . Кроме того, интеграция с LLM предполагает сетевое общение с моделями (либо по локальному интерфейсу, либо через интернет). Протоколы, используемые AIOS, в основном HTTP/HTTPS. Прямой работы с сокетами на низком уровне не зафиксировано – вместо этого разработчики опираются на высокоуровневые клиенты (requests, openai SDK и т.п.). Это упрощает разработку и делает код более переносимым.

## Взаимодействие с системными сервисами (D-Bus, systemd и др.)

При анализе исходного кода не обнаружено прямых обращений к специфичным для ОС службам вроде D-Bus, systemd, journald и т.п. AIOS функционирует на уровне пользовательского пространства и использует стандартные библиотеки Python для большинства задач, избегая зависимостей от конкретных Linux-сервисов. Несколько наблюдений:
	•	Логирование и мониторинг: AIOS ведёт собственный лог работы (например, через logging библиотеки Python). В коде scheduler (планировщика) видны вызовы logger.info для отслеживания состояния агентов . Запись логов происходит в консоль или файл, но нет указаний на интеграцию с системным журналом (systemd journal). Вероятно, разработчики рассчитывают, что AIOS будет запускаться как обычный процесс, и логирование можно перенаправить в файлы или обрабатывать внешними средствами при желании. В Docker-файле проекта, скорее всего, AIOS запускается foreground, и логи Docker контейнера можно агрегировать стандартными методами – но это вне самого приложения.
	•	D-Bus: Ни в одном из просмотренных файлов или обсуждений нет упоминаний D-Bus. AIOS не пытается, например, отправлять уведомления через Desktop Environment, не слушает системные события через шину – по крайней мере, пока. Это соответствует кроссплатформенности: D-Bus специфичен для Linux, и его отсутствие говорит о том, что AIOS не завязан на Linux-демоны. Вместо этого все необходимые системные взаимодействия реализованы средствами Python, что обеспечивает работу и на Windows/macOS.
	•	Systemd и запуск как сервис: Проект не содержит unit-файлов или специальных инструкций для systemd. Управление процессом AIOS выполняется пользователем (либо напрямую python main.py, либо через Docker). Нет признаков, что AIOS регистрируется как системный сервис, взаимодействует с systemctl или подобными вещами. При необходимости пользователь сам может обернуть AIOS в service, но на уровне кода это не предусмотрено.
	•	ОС-специфичные ветви: Как уже отмечалось, код базируется на переносимых инструментах. Нет явных условных выражений вида if sys.platform == 'linux': ... elif sys.platform == 'win32': ... в основной логике. Это говорит о том, что AIOS пытается абстрагироваться от различий ОС. Некоторые различия могут касаться путей по умолчанию (например, расположение модели HuggingFace – переменная HF_HOME может указывать на разные каталоги в Linux vs Windows), но эти параметры настраиваются через конфигурацию, а не жестко прописаны в коде для каждой ОС.
	•	Исключения: Единственный возможный аспект – интеграция Terminal UI в Windows. Если Terminal UI опирается на псевдо-терминалы или Unix-специфичные библиотеки (например, curses), на Windows это может не работать из коробки. Документация явно не указывает ограничений, а разработчики в issue уточняют версию ОС у пользователей при проблемах  . Вероятно, большинство функций тестировались на Linux (Ubuntu 22.04, как в примере), и на Windows/Mac некоторые сценарии могут требовать адаптации. Однако, это выражается не в специальном коде, а скорее в дополнительных инструкциях (например, установить определённые зависимости для Windows, запускать от администратора и пр.).

Таким образом, взаимодействие с системными службами отсутствует или сведено к минимуму. AIOS не использует сервисы типа cron, systemd timers или D-Bus уведомлений. Все операции реализованы на уровне процесса AIOS и его Python-модулей. Это архитектурное решение соответствует идее, что AIOS – кроссплатформенный “пользовательский” уровень над ОС, а не часть самой ОС.

## ОС Linux vs Windows: отличия в коде

AIOS спроектирован быть кроссплатформенным, поэтому особых конструкций, зависящих от Linux, в коде не просматривается. Тем не менее, в контексте Linux некоторые моменты стоит упомянуть:
	•	Пути и разделители: Использование os.path и pathlib автоматически учитывает разделители путей для текущей ОС. Например, кэш агента agenthub/cache/... на Windows будет создаваться в аналогичном виде (внутри рабочей директории), просто с другими слэшами. Код не зашит под конкретный тип слэшей, он опирается на функции вроде os.path.join, что предотвращает ошибки.
	•	Исполняемые файлы: В Linux запуск внешних утилит (если бы они были) потребовал бы учета прав исполнения. Поскольку AIOS практически не вызывает внешние бинарники напрямую, этот аспект не влияет. Разве что в Dockerfile на Linux базовом образе устанавливаются нужные пакеты (например, apt-get для system dependencies), но внутри Python-кода этого нет.
	•	GPU и драйверы: Взаимодействие с аппаратной частью (GPU) происходит через фреймворки (PyTorch, etc.), которые под Linux используют CUDA. В файле requirements-cuda.txt приводятся зависимости под CUDA-версии библиотек, что намекает на OS-specific установку (в Windows, CUDA-библиотеки устанавливаются иначе). Однако сам AIOS не видит разницы – это уровень зависимостей, а не логики. Пример: в Linux нужно наличие драйвера NVIDIA и соответствующих библиотек, но AIOS просто вызывает torch.cuda.is_available() – нет разницы, Windows это или Linux.
	•	Windows-конструкции: Специфичный код для Windows (например, использование ctypes.WinDLL или взаимодействие с Win32 API) отсутствует. Единственное, что может отличаться – способ запуска терминала. На Windows нет встроенной поддержки псевдо-терминалов; если Terminal UI AIOS реализован через эмуляцию shell, возможно, там учитывается отсутствие /dev/pty. Но опять же, в исходниках нет явных признаков этого, возможно Terminal UI на Windows работает упрощенно (или требует Windows Terminal).

В целом, разработчики явно целились в Linux как основную платформу (что типично для систем AI), но при этом не ограничили себя только ей. Кодовая база не содержит непреносимых вызовов. Упоминание fork() (только Unix) или D-Bus (Linux) отсутствует. Следовательно, AIOS может запускаться в разных ОС при наличии Python 3.10+ и соответствующих библиотек (вплоть до успешных отчетов о запуске на Termux/Android , где также Linux-окружение).

## Примеры файлов и фрагментов кода

Ниже перечислены конкретные места в исходниках AIOS, иллюстрирующие взаимодействие с ОС:
	•	Чтение переменных окружения: файл src/tools/online/bing_search.py (класс BingSearch) – загрузка API-ключа Bing: self.bing_subscription_key = get_from_env("BING_SUBSCRIPTION_KEY") .
	•	HTTP-запрос к внешнему API: там же, BingSearch – выполнение запроса: requests.get(self.bing_search_url, headers=headers, params=params) для отправки поискового запроса Bing .
	•	HTTP-запрос во внутренней сети: файл pyopenagi/manager.py – метод загрузки агента: requests.get(f"{self.base_url}/api/download", params=...) (пример запроса к локальному Agent Hub) .
	•	Создание каталога на диске: файл aios/storage/filesystem/lsfs.py – фрагмент, где создается директория хранения: os.makedirs(dir_path) .
	•	Чтение файла с диска: файл aios/storage/filesystem/lsfs.py – функция чтения: with open(file_path, 'r') as f: content = f.read() .
	•	Загрузка/кеширование модели или агента: при инициализации LLM может создаваться локальная папка (например, ~/.cache/huggingface). Это не явно в коде AIOS, а происходит внутри библиотек (transformers). Но AIOS позволяет задать HF_HOME для управления этим путём  – тем самым косвенно взаимодействуя с ФС (через переменные окружения).
	•	Логирование и статусы: файл aios/scheduler/base_scheduler.py – фиксация статуса агента: logger.info(f"[{agent_process.agent_name}] is executing.")  – пишет в лог, который выводится в stdout или файл, то есть взаимодействует с окружением выполнения (консоль).
	•	Конфигурация и OS: aios/config/aios_config.json – содержит настройки (пути, флаги) для разных компонентов. Например, там могут быть указаны пути к моделям, URLs сервисов и пр., что позволяет адаптировать поведение под ОС без изменения кода.

## Заключение

Проект AIOS (AI Agent Operating System) реализует богатое взаимодействие с ОС, при этом делая это на высокоуровневых, переносимых примитивах Python. Он выполняет операции файловой системы (создание папок, чтение/запись файлов, копирование) с помощью стандартных функций (os, open, shutil), осуществляет сетевые запросы к внешним и внутренним сервисам через HTTP (requests), но не привязывается к специфике Linux (отсутствуют обращения к D-Bus, systemd и прочим платформенным API). Код организован так, что AIOS выступает прослойкой между агентами и ОС: с одной стороны, позволяя агентам выполнять “системные” действия (как бы через системные вызовы AIOS), с другой – переводя их в реальные вызовы Python к ОС.

В контексте Linux AIOS работает “из коробки”, используя возможности ядра Linux только опосредованно (через Python). Если встречаются моменты, требующие учёта ОС, они решаются настройкой (например, разные ключи API или пути), а не разными кодовыми базами. Windows и другие ОС должны поддерживаться благодаря такому подходу, хотя на практике наибольшее внимание уделяется Linux-среде (особенно для GPU и модельных inference).

Подводя итог, AIOS взаимодействует с ОС-хостом следующим образом:
	•	Вызывает файловые операции (создание каталогов, чтение и запись файлов, копирование) через Python (os.makedirs, open, и т.д.), что эквивалентно системным вызовам чтения/записи в Linux  .
	•	Выполняет сетевые операции через HTTP: интегрированы вызовы внешних API (интернет-сервисы)  и предусмотрена коммуникация между компонентами AIOS по REST-протоколу .
	•	Не использует Linux-специфичных API напрямую – никакого D-Bus, systemd, или оболочек Bash в общем случае; всё реализовано средствами, доступными на всех платформах.
	•	Кроссплатформенность: код одинаково обращается с ресурсами ОС, полагаясь на абстракции Python. Отличия ОС влияют лишь на окружение выполнения (наличие тех или иных утилит, драйверов), но не требуют изменения логики AIOS.

Такой дизайн делает AIOS похожим на виртуальную прослойку ОС, где роль “системных вызовов” выполняют функции Python. Это подтверждает концепцию AIOS как операционной системы для AI-агентов: реальные системные взаимодействия инкапсулированы внутри, и для агента выглядят как простые функции, хотя “под капотом” происходят вызовы к файловой системе и сетевые запросы хост-ОС.

## Источники:
	•	Анализ исходного кода AIOS (репозиторий GitHub agiresearch/AIOS) – фрагменты кода, отвечающие за работу с ОС: создание каталогов , HTTP-запросы  , чтение файлов  и др.
	•	Официальная документация AIOS и заметки разработчиков – описание функционала (Storage API, Tool API и др.) и архитектурных решений  .
	•	Обсуждения в Issue-трекере проекта – подтверждение поведения на разных ОС и акцентов (вопросы про среду Ubuntu vs Windows)  .